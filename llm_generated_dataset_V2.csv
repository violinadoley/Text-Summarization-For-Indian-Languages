Comments,Surrounding Code Context,Class
Transforms a function operating on strings/words to one operating on numeric indices,"def conjugate(self, f): return lambda i: self.word_index[f(self.index_word[i])]",Useful
"Splits the dataset into test, validation, and training sets based on repository IDs",test = empty | df.repo_id.map(test_repos.__contains__) valid = ~empty & df.repo_id.map(valid_repos.__contains__) train = ~valid & ~test,Useful
Calculates the Levenshtein distance between two sequences,"fn calculate_levenshtein_distance<T: Eq>(s1: &[T], s2: &[T]) -> usize { let len_s1 = s1.len(); let len_s2 = s2.len(); let mut matrix: Vec<Vec<usize>> = vec![vec![0; len_s2 + 1]; len_s1 + 1]; for i in 0..=len_s1 { matrix[i][0] = i; } for j in 0..=len_s2 { matrix[0][j] = j; } for (i, item1) in s1.iter().enumerate() { for (j, item2) in s2.iter().enumerate() { let cost = if item1 == item2 { 0 } else { 1 }; matrix[i + 1][j + 1] = [matrix[i][j + 1] + 1, matrix[i + 1][j] + 1, matrix[i][j] + cost].iter().min().unwrap().clone(); } } matrix[len_s1][len_s2] }",Useful
Creates a memoized version of a function to cache results,"const memoize = (fn) => { const cache = new Map(); return (...args) => { const key = JSON.stringify(args); if (cache.has(key)) return cache.get(key); const result = fn.apply(this, args); cache.set(key, result); return result; }; };",Useful
Implements a thread-safe queue using mutex and condition variable,"template<typename T> class ThreadSafeQueue { private: std::queue<T> queue; mutable std::mutex mutex; std::condition_variable cond; public: void push(T item) { std::lock_guard<std::mutex> lock(mutex); queue.push(std::move(item)); cond.notify_one(); } T pop() { std::unique_lock<std::mutex> lock(mutex); cond.wait(lock, [this]{ return !queue.empty(); }); T item = std::move(queue.front()); queue.pop(); return item; } };",Useful
Defines a coroutine decorator and a grep coroutine for pattern matching,"def coroutine(func): def start(*args, **kwargs): cr = func(*args, **kwargs) next(cr) return cr return start @coroutine def grep(pattern): print(f""Looking for {pattern}"") while True: line = yield if pattern in line: print(line)",Useful
Implements the merge sort algorithm in Rust,fn merge_sort<T: Ord + Clone>(arr: &mut [T]) { if arr.len() <= 1 { return; } let mid = arr.len() / 2; merge_sort(&mut arr[..mid]); merge_sort(&mut arr[mid..]); let mut left = arr[..mid].to_vec(); let mut right = arr[mid..].to_vec(); let mut i = 0; let mut j = 0; let mut k = 0; while i < left.len() && j < right.len() { if left[i] <= right[j] { arr[k] = left[i].clone(); i += 1; } else { arr[k] = right[j].clone(); j += 1; } k += 1; } while i < left.len() { arr[k] = left[i].clone(); i += 1; k += 1; } while j < right.len() { arr[k] = right[j].clone(); j += 1; k += 1; } },Useful
Implements a Least Recently Used (LRU) cache,"class LRUCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = {} self.order = collections.deque() def get(self, key: int) -> int: if key not in self.cache: return -1 self.order.remove(key) self.order.appendleft(key) return self.cache[key] def put(self, key: int, value: int) -> None: if key in self.cache: self.order.remove(key) elif len(self.cache) >= self.capacity: oldest = self.order.pop() del self.cache[oldest] self.cache[key] = value self.order.appendleft(key)",Useful
Implements function currying in JavaScript,"const curry = (fn) => { const arity = fn.length; return function curried(...args) { if (args.length >= arity) { return fn.apply(this, args); } else { return function(...moreArgs) { return curried.apply(this, args.concat(moreArgs)); }; } }; };",Useful
Implements a shared pointer class in C++,"template <typename T> class SharedPtr { private: T* ptr; int* refCount; public: SharedPtr(T* p = nullptr) : ptr(p), refCount(new int(1)) {} SharedPtr(const SharedPtr& other) : ptr(other.ptr), refCount(other.refCount) { (*refCount)++; } SharedPtr& operator=(const SharedPtr& other) { if (this != &other) { release(); ptr = other.ptr; refCount = other.refCount; (*refCount)++; } return *this; } ~SharedPtr() { release(); } T& operator*() const { return *ptr; } T* operator->() const { return ptr; } private: void release() { if (--(*refCount) == 0) { delete ptr; delete refCount; } } };",Useful
Implements an exponential backoff retry mechanism for asynchronous functions,"async function retryWithBackoff(fn, maxRetries = 5, baseDelay = 1000) { for (let i = 0; i < maxRetries; i++) { try { return await fn(); } catch (error) { if (i === maxRetries - 1) throw error; const delay = baseDelay * Math.pow(2, i); await new Promise(resolve => setTimeout(resolve, delay)); } } }",Useful
Performs a topological sort on a directed acyclic graph,def topological_sort(graph): def dfs(node): if node in visited: return visited.add(node) for neighbor in graph[node]: dfs(neighbor) result.append(node) visited = set() result = [] for node in graph: dfs(node) return result[::-1],Useful
Implements the quicksort algorithm in Rust,"fn quicksort<T: Ord>(arr: &mut [T]) { if arr.len() <= 1 { return; } let pivot = partition(arr); quicksort(&mut arr[..pivot]); quicksort(&mut arr[pivot + 1..]); } fn partition<T: Ord>(arr: &mut [T]) -> usize { let pivot = arr.len() - 1; let mut i = 0; for j in 0..pivot { if arr[j] <= arr[pivot] { arr.swap(i, j); i += 1; } } arr.swap(i, pivot); i }",Useful
Implements the Observer pattern in JavaScript,class Observable { constructor() { this.observers = []; } subscribe(fn) { this.observers.push(fn); } unsubscribe(fn) { this.observers = this.observers.filter(subscriber => subscriber !== fn); } notify(data) { this.observers.forEach(observer => observer(data)); } },Useful
Implements a fixed-size circular buffer in C++,"template <typename T, size_t N> class FixedCircularBuffer { private: std::array<T, N> buffer; size_t head = 0; size_t tail = 0; bool full = false; public: void push(const T& item) { buffer[head] = item; if (full) { tail = (tail + 1) % N; } head = (head + 1) % N; full = head == tail; } T pop() { if (empty()) { throw std::runtime_error(""Buffer is empty""); } T item = buffer[tail]; full = false; tail = (tail + 1) % N; return item; } bool empty() const { return (!full && (head == tail)); } bool full() const { return full; } size_t size() const { if (full) { return N; } if (head >= tail) { return head - tail; } return N + head - tail; } };",Useful
Calculates the length of the Longest Common Subsequence (LCS) of two sequences,"def lcs(X, Y): m, n = len(X), len(Y) L = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if X[i-1] == Y[j-1]: L[i][j] = L[i-1][j-1] + 1 else: L[i][j] = max(L[i-1][j], L[i][j-1]) return L[m][n]",Useful
Implements primality test and Sieve of Eratosthenes for prime number generation,fn is_prime(n: u64) -> bool { if n <= 1 { return false; } if n <= 3 { return true; } if n % 2 == 0 || n % 3 == 0 { return false; } let mut i = 5; while i * i <= n { if n % i == 0 || n % (i + 2) == 0 { return false; } i += 6; } true } fn sieve_of_eratosthenes(n: usize) -> Vec<bool> { let mut is_prime = vec![true; n + 1]; is_prime[0] = false; is_prime[1] = false; let mut p = 2; while p * p <= n { if is_prime[p] { let mut i = p * p; while i <= n { is_prime[i] = false; i += p; } } p += 1; } is_prime },Useful
Implements a Trie data structure for efficient string operations,"class Trie: def __init__(self): self.root = {} def insert(self, word: str) -> None: node = self.root for char in word: if char not in node: node[char] = {} node = node[char] node['$'] = True def search(self, word: str) -> bool: node = self.root for char in word: if char not in node: return False node = node[char] return '$' in node def startsWith(self, prefix: str) -> bool: node = self.root for char in prefix: if char not in node: return False node = node[char] return True",Useful
Implements a debounce function to limit the rate at which a function can fire,"const debounce = (func, delay) => { let timeoutId; return function (...args) { clearTimeout(timeoutId); timeoutId = setTimeout(() => { func.apply(this, args); }, delay); }; };",Useful
Implements a simple thread pool for parallel task execution in C++,"template <typename T> class ThreadPool { private: std::vector<std::thread> workers; std::queue<T> tasks; std::mutex queue_mutex; std::condition_variable condition; bool stop; public: ThreadPool(size_t threads) : stop(false) { for (size_t i = 0; i < threads; ++i) { workers.emplace_back([this] { while (true) { T task; { std::unique_lock<std::mutex> lock(this->queue_mutex); this->condition.wait(lock, [this] { return this->stop || !this->tasks.empty(); }); if (this->stop && this->tasks.empty()) { return; } task = std::move(this->tasks.front()); this->tasks.pop(); } task(); } }); } template <class F> void enqueue(F&& f) { { std::unique_lock<std::mutex> lock(queue_mutex); tasks.emplace(std::forward<F>(f)); } condition.notify_one(); } ~ThreadPool() { { std::unique_lock<std::mutex> lock(queue_mutex); stop = true; } condition.notify_all(); for (std::thread& worker : workers) { worker.join(); } } };",Useful
Implements the Floyd-Warshall algorithm for all-pairs shortest path,"def floyd_warshall(graph): V = len(graph) dist = [[float('inf')] * V for _ in range(V)] for i in range(V): for j in range(V): dist[i][j] = graph[i][j] for k in range(V): for i in range(V): for j in range(V): dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]) return dist",Useful
Implements the Knuth-Morris-Pratt (KMP) string matching algorithm in Rust,"fn kmp_search(text: &str, pattern: &str) -> Vec<usize> { let text = text.as_bytes(); let pattern = pattern.as_bytes(); let mut lps = vec![0; pattern.len()]; let mut len = 0; let mut i = 1; while i < pattern.len() { if pattern[i] == pattern[len] { len += 1; lps[i] = len; i += 1; } else if len != 0 { len = lps[len - 1]; } else { lps[i] = 0; i += 1; } } let mut result = Vec::new(); let mut i = 0; let mut j = 0; while i < text.len() { if pattern[j] == text[i] { i += 1; j += 1; } if j == pattern.len() { result.push(i - j); j = lps[j - 1]; } else if i < text.len() && pattern[j] != text[i] { if j != 0 { j = lps[j - 1]; } else { i += 1; } } } result }",Useful
Implements a max priority queue using a binary heap in JavaScript,"class PriorityQueue { constructor() { this.heap = []; } parent(i) { return Math.floor((i - 1) / 2); } leftChild(i) { return 2 * i + 1; } rightChild(i) { return 2 * i + 2; } swap(i, j) { [this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]]; } insert(key) { this.heap.push(key); this.heapifyUp(this.heap.length - 1); } extractMax() { if (this.heap.length === 0) return null; if (this.heap.length === 1) return this.heap.pop(); const max = this.heap[0]; this.heap[0] = this.heap.pop(); this.heapifyDown(0); return max; } heapifyUp(i) { while (i > 0 && this.heap[this.parent(i)] < this.heap[i]) { this.swap(i, this.parent(i)); i = this.parent(i); } } heapifyDown(i) { let maxIndex = i; const left = this.leftChild(i); const right = this.rightChild(i); if (left < this.heap.length && this.heap[left] > this.heap[maxIndex]) { maxIndex = left; } if (right < this.heap.length && this.heap[right] > this.heap[maxIndex]) { maxIndex = right; } if (i !== maxIndex) { this.swap(i, maxIndex); this.heapifyDown(maxIndex); } } }",Useful
Implements the Rabin-Karp string matching algorithm,"def rabin_karp(text, pattern): d = 256 q = 101 m = len(pattern) n = len(text) p = 0 t = 0 h = 1 result = [] for i in range(m-1): h = (h * d) % q for i in range(m): p = (d * p + ord(pattern[i])) % q t = (d * t + ord(text[i])) % q for i in range(n - m + 1): if p == t: if text[i:i+m] == pattern: result.append(i) if i < n - m: t = (d * (t - ord(text[i]) * h) + ord(text[i + m])) % q if t < 0: t += q return result",Useful
Implements the Bellman-Ford algorithm for finding shortest paths in a weighted graph,"fn bellman_ford(graph: &Vec<Vec<(usize, i32)>>, start: usize) -> Option<Vec<i32>> { let n = graph.len(); let mut dist = vec![i32::MAX; n]; dist[start] = 0; for _ in 0..n-1 { for u in 0..n { for &(v, w) in &graph[u] { if dist[u] != i32::MAX && dist[u] + w < dist[v] { dist[v] = dist[u] + w; } } } } for u in 0..n { for &(v, w) in &graph[u] { if dist[u] != i32::MAX && dist[u] + w < dist[v] { return None; } } } Some(dist) }",Useful
Implements a Bloom filter data structure for probabilistic set membership testing,"class BloomFilter { constructor(size, hashFunctions) { this.size = size; this.hashFunctions = hashFunctions; this.bitArray = new Array(size).fill(0); } add(item) { this.hashFunctions.forEach(hashFunc => { const index = hashFunc(item) % this.size; this.bitArray[index] = 1; }); } contains(item) { return this.hashFunctions.every(hashFunc => { const index = hashFunc(item) % this.size; return this.bitArray[index] === 1; }); } }",Useful
Implements Tarjan's algorithm for finding strongly connected components in a directed graph,"def tarjan_scc(graph): index = 0 stack = [] on_stack = set() indices = {} lowlinks = {} sccs = [] def strongconnect(v): nonlocal index indices[v] = index lowlinks[v] = index index += 1 stack.append(v) on_stack.add(v) for w in graph[v]: if w not in indices: strongconnect(w) lowlinks[v] = min(lowlinks[v], lowlinks[w]) elif w in on_stack: lowlinks[v] = min(lowlinks[v], indices[w]) if lowlinks[v] == indices[v]: scc = [] while True: w = stack.pop() on_stack.remove(w) scc.append(w) if w == v: break sccs.append(scc) for v in graph: if v not in indices: strongconnect(v) return sccs",Useful
Implements Huffman coding for text compression in Rust,"fn huffman_encoding(text: &str) -> (String, std::collections::HashMap<char, String>) { use std::collections::{BinaryHeap, HashMap}; use std::cmp::Reverse; let mut freq = HashMap::new(); for c in text.chars() { *freq.entry(c).or_insert(0) += 1; } let mut heap = BinaryHeap::new(); for (c, f) in freq.iter() { heap.push(Reverse((f, *c, String::new()))); } while heap.len() > 1 { let Reverse((f1, c1, code1)) = heap.pop().unwrap(); let Reverse((f2, c2, code2)) = heap.pop().unwrap(); let mut new_code1 = code1.clone(); let mut new_code2 = code2.clone(); new_code1.insert(0, '0'); new_code2.insert(0, '1'); heap.push(Reverse((f1 + f2, '\0', String::new()))); heap.push(Reverse((f1, c1, new_code1))); heap.push(Reverse((f2, c2, new_code2))); } let mut encoding = HashMap::new(); while let Some(Reverse((_, c, code))) = heap.pop() { if c != '\0' { encoding.insert(c, code); } } let encoded = text.chars().map(|c| encoding[&c].clone()).collect(); (encoded, encoding) }",Useful
Implements a segment tree for range queries and updates in JavaScript,"class SegmentTree { constructor(arr) { this.n = arr.length; this.tree = new Array(4 * this.n).fill(0); this.build(arr, 1, 0, this.n - 1); } build(arr, node, start, end) { if (start === end) { this.tree[node] = arr[start]; return; } const mid = Math.floor((start + end) / 2); this.build(arr, 2 * node, start, mid); this.build(arr, 2 * node + 1, mid + 1, end); this.tree[node] = this.tree[2 * node] + this.tree[2 * node + 1]; } update(index, value, node = 1, start = 0, end = this.n - 1) { if (start === end) { this.tree[node] = value; return; } const mid = Math.floor((start + end) / 2); if (index <= mid) { this.update(index, value, 2 * node, start, mid); } else { this.update(index, value, 2 * node + 1, mid + 1, end); } this.tree[node] = this.tree[2 * node] + this.tree[2 * node + 1]; } query(left, right, node = 1, start = 0, end = this.n - 1) { if (right < start || end < left) return 0; if (left <= start && end <= right) return this.tree[node]; const mid = Math.floor((start + end) / 2); const leftSum = this.query(left, right, 2 * node, start, mid); const rightSum = this.query(left, right, 2 * node + 1, mid + 1, end); return leftSum + rightSum; } }",Useful
Implements the 0/1 Knapsack problem using dynamic programming,"def knapsack(weights, values, capacity): n = len(values) dp = [[0 for _ in range(capacity + 1)] for _ in range(n + 1)] for i in range(n + 1): for w in range(capacity + 1): if i == 0 or w == 0: dp[i][w] = 0 elif weights[i - 1] <= w: dp[i][w] = max(values[i - 1] + dp[i - 1][w - weights[i - 1]], dp[i - 1][w]) else: dp[i][w] = dp[i - 1][w] return dp[n][capacity]",Useful
Implements binary search algorithm in Rust,"fn binary_search(arr: &[i32], target: i32) -> Option<usize> { let mut left = 0; let mut right = arr.len() as isize - 1; while left <= right { let mid = (left + right) / 2; if arr[mid as usize] == target { return Some(mid as usize); } else if arr[mid as usize] < target { left = mid + 1; } else { right = mid - 1; } } None }",Useful
Implements a stack data structure in JavaScript,class Stack { constructor() { this.items = []; } push(item) { this.items.push(item); } pop() { return this.items.pop(); } peek() { return this.items[this.items.length - 1]; } isEmpty() { return this.items.length === 0; } size() { return this.items.length; } },Useful
Implements the merge sort algorithm in Python,def mergesort(arr): if len(arr) > 1: mid = len(arr) // 2 L = arr[:mid] R = arr[mid:] mergesort(L) mergesort(R) i = j = k = 0 while i < len(L) and j < len(R): if L[i] < R[j]: arr[k] = L[i] i += 1 else: arr[k] = R[j] j += 1 k += 1 while i < len(L): arr[k] = L[i] i += 1 k += 1 while j < len(R): arr[k] = R[j] j += 1 k += 1,Useful
Calculates the factorial of a number using recursion in Rust,fn factorial(n: u32) -> u32 { if n == 0 { return 1; } factorial(n - 1) * n },Useful
Calculates the nth Fibonacci number using recursion,def fibonacci(n): if n <= 1: return n return fibonacci(n - 1) + fibonacci(n - 2),Useful
This function implements the merge sort algorithm on the input array.,def merge_sort(arr): if len(arr) > 1: mid = len(arr) // 2; L = arr[:mid]; R = arr[mid:]; merge_sort(L); merge_sort(R); i = j = k = 0; while i < len(L) and j < len(R): if L[i] < R[j]: arr[k] = L[i]; i += 1; else: arr[k] = R[j]; j += 1; k += 1; while i < len(L): arr[k] = L[i]; i += 1; k += 1; while j < len(R): arr[k] = R[j]; j += 1; k += 1,Useful
This function delays the execution of a given function until after a specified wait time.,"function debounce(func, wait) { let timeout; return function executedFunction(...args) { const later = () => { timeout = null; if (args) func(...args); }; clearTimeout(timeout); timeout = setTimeout(later, wait); }; };",Useful
Defines a binary tree node structure with left and right child pointers.,"struct Node { int data; Node* left; Node* right; Node(int val) : data(val), left(nullptr), right(nullptr) {} };",Useful
Calculates the factorial of a given number using a range and product.,pub fn factorial(n: u64) -> u64 { (1..=n).product() },Useful
Fetches data from a given URL asynchronously and returns the parsed JSON.,async function fetchData(url) { const response = await fetch(url); const data = await response.json(); return data; },Useful
Implements the quick sort algorithm to sort an array.,def quick_sort(arr): if len(arr) <= 1: return arr; pivot = arr[len(arr) // 2]; left = [x for x in arr if x < pivot]; middle = [x for x in arr if x == pivot]; right = [x for x in arr if x > pivot]; return quick_sort(left) + middle + quick_sort(right),Useful
Limits the rate at which a function can be executed to a specified limit.,"function throttle(func, limit) { let lastFunc; let lastRan; return function() { const context = this; const args = arguments; if (!lastRan) { func.apply(context, args); lastRan = Date.now(); } else { clearTimeout(lastFunc); lastFunc = setTimeout(function() { if ((Date.now() - lastRan) >= limit) { func.apply(context, args); lastRan = Date.now(); } }, limit - (Date.now() - lastRan)); } };",Useful
"Defines a generic stack class that supports push, pop, and is_empty operations.","template<typename T> class Stack { private: std::vector<T> elements; public: void push(const T& element) { elements.push_back(element); } T pop() { if(elements.empty()) throw std::out_of_range(""Stack<>::pop(): empty stack""); T elem = elements.back(); elements.pop_back(); return elem; } bool is_empty() const { return elements.empty(); } };",Useful
Calculates the nth Fibonacci number using recursion.,"fn fibonacci(n: u32) -> u32 { match n { 0 => 0, 1 => 1, _ => fibonacci(n - 1) + fibonacci(n - 2) } }",Useful
Creates a linked list with an append method to add values to the list.,"class LinkedList { constructor() { this.head = null; } append(value) { let newNode = { value, next: null }; if (!this.head) { this.head = newNode; return; } let current = this.head; while (current.next) { current = current.next; } current.next = newNode; } }",Useful
Implements the dynamic programming solution to the 0/1 knapsack problem.,"def knapsack(weights, values, capacity): n = len(values); K = [[0 for _ in range(capacity + 1)] for _ in range(n + 1)]; for i in range(n + 1): for w in range(capacity + 1): if i == 0 or w == 0: K[i][w] = 0; elif weights[i-1] <= w: K[i][w] = max(values[i-1] + K[i-1][w-weights[i-1]], K[i-1][w]); else: K[i][w] = K[i-1][w]; return K[n][capacity]",Useful
Loads an image from a URL and returns a promise that resolves with the image.,"async function loadImage(url) { const img = new Image(); img.src = url; return new Promise((resolve, reject) => { img.onload = () => resolve(img); img.onerror = reject; }); }",Useful
Defines a binary tree class with a method to insert new values.,"class BinaryTree { constructor(value) { this.root = { value, left: null, right: null }; } insert(value) { const insertNode = (node, value) => { if (!node) return { value, left: null, right: null }; if (value < node.value) { node.left = insertNode(node.left, value); } else { node.right = insertNode(node.right, value); } return node; }; this.root = insertNode(this.root, value); } }",Useful
Implements binary search algorithm to find the index of a target value in a sorted array.,"def binary_search(arr, target): left, right = 0, len(arr) - 1; while left <= right: mid = (left + right) // 2; if arr[mid] == target: return mid; elif arr[mid] < target: left = mid + 1; else: right = mid - 1; return -1",Useful
Checks if a given string is a palindrome.,function isPalindrome(str) { const reversed = str.split('').reverse().join(''); return str === reversed; },Useful
Implements the quicksort algorithm in C++ to sort an array.,"template<typename T> void quicksort(std::vector<T>& arr, int left, int right) { int i = left, j = right; T pivot = arr[(left + right) / 2]; while (i <= j) { while (arr[i] < pivot) i++; while (arr[j] > pivot) j--; if (i <= j) { std::swap(arr[i], arr[j]); i++; j--; } } if (left < j) quicksort(arr, left, j); if (i < right) quicksort(arr, i, right); }",Useful
Sorts a slice of elements using the merge sort algorithm.,"pub fn merge_sort<T: Ord>(arr: &mut [T]) { let mid = arr.len() / 2; if mid == 0 { return; } merge_sort(&mut arr[..mid]); merge_sort(&mut arr[mid..]); let mut result = Vec::with_capacity(arr.len()); let (mut left, mut right) = (0, mid); while left < mid && right < arr.len() { if arr[left] <= arr[right] { result.push(arr[left]); left += 1; } else { result.push(arr[right]); right += 1; } } result.extend_from_slice(&arr[left..mid]); result.extend_from_slice(&arr[right..]); arr.copy_from_slice(&result); }",Useful
Defines a graph class that allows adding nodes and edges.,"class Graph { constructor() { this.nodes = {}; } addNode(node) { this.nodes[node] = []; } addEdge(node1, node2) { this.nodes[node1].push(node2); this.nodes[node2].push(node1); } }",Useful
Implements Dijkstra's algorithm to find the shortest paths from a starting vertex in a graph.,"def dijkstra(graph, start): shortest_paths = {vertex: float('infinity') for vertex in graph}; shortest_paths[start] = 0; pq = [(0, start)]; while pq: current_distance, current_vertex = heapq.heappop(pq); for neighbor, weight in graph[current_vertex].items(): distance = current_distance + weight; if distance < shortest_paths[neighbor]: shortest_paths[neighbor] = distance; heapq.heappush(pq, (distance, neighbor)); return shortest_paths",Useful
Sorts an array using the selection sort algorithm.,"function selectionSort(arr) { for (let i = 0; i < arr.length - 1; i++) { let minIndex = i; for (let j = i + 1; j < arr.length; j++) { if (arr[j] < arr[minIndex]) { minIndex = j; } } if (minIndex !== i) { [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]]; } } return arr; }",Useful
Defines an AVL tree class with insertion and balancing methods.,"class AVLTree { constructor() { this.root = null; } insert(value) { this.root = this._insert(this.root, value); } _insert(node, value) { if (!node) return new Node(value); if (value < node.value) node.left = this._insert(node.left, value); else if (value > node.value) node.right = this._insert(node.right, value); return this._balance(node); } _balance(node) { // Balancing logic here } }",Useful
Implements breadth-first search algorithm to traverse a graph.,"def bfs(graph, start): visited = set(); queue = [start]; while queue: vertex = queue.pop(0); if vertex not in visited: visited.add(vertex); queue.extend(set(graph[vertex]) - visited); return visited",Useful
Merges two sorted arrays into one sorted array.,"function mergeArrays(arr1, arr2) { let merged = []; let i = 0, j = 0; while (i < arr1.length && j < arr2.length) { if (arr1[i] < arr2[j]) { merged.push(arr1[i++]); } else { merged.push(arr2[j++]); } } return merged.concat(arr1.slice(i)).concat(arr2.slice(j)); }",Useful
Calculates the depth of a binary tree recursively.,"pub fn binary_tree_depth<T>(node: &Option<Box<Node<T>>>) -> usize { match node { Some(n) => 1 + binary_tree_depth(&n.left).max(binary_tree_depth(&n.right)), None => 0, } }",Useful
Defines a simple queue class with enqueue and dequeue methods.,class Queue { constructor() { this.items = []; } enqueue(item) { this.items.push(item); } dequeue() { return this.items.shift(); } isEmpty() { return this.items.length === 0; } },Useful
Determines whether a number is prime or not.,"def is_prime(num): if num < 2: return False; for i in range(2, int(num**0.5) + 1): if num % i == 0: return False; return True",Useful
Calculates the factorial of a number using recursion.,function factorial(n) { if (n < 0) return undefined; return n === 0 ? 1 : n * factorial(n - 1); },Useful
Defines a max heap data structure with insertion functionality.,"class MaxHeap { constructor() { this.heap = []; } insert(num) { this.heap.push(num); this.bubbleUp(); } bubbleUp() { let index = this.heap.length - 1; while (index > 0) { let parentIndex = Math.floor((index - 1) / 2); if (this.heap[parentIndex] >= this.heap[index]) break; [this.heap[parentIndex], this.heap[index]] = [this.heap[index], this.heap[parentIndex]]; index = parentIndex; } } }",Useful
Removes duplicates from a vector in Rust.,pub fn remove_duplicates(vec: &mut Vec<i32>) { let mut seen = HashSet::new(); vec.retain(|&x| seen.insert(x)); },Useful
Rotates an array to the right by k steps.,"def rotate_array(arr, k): k = k % len(arr); return arr[-k:] + arr[:-k]",Useful
Performs binary search on a sorted array to find the target index.,"function binarySearch(arr, target) { let left = 0, right = arr.length - 1; while (left <= right) { const mid = Math.floor((left + right) / 2); if (arr[mid] === target) return mid; if (arr[mid] < target) left = mid + 1; else right = mid - 1; } return -1; }",Useful
Computes the length of the longest common subsequence between two strings.,"def longest_common_subsequence(a, b): m, n = len(a), len(b); dp = [[0] * (n + 1) for _ in range(m + 1)]; for i in range(1, m + 1): for j in range(1, n + 1): if a[i - 1] == b[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1; else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); return dp[m][n]",Useful
Defines a trie data structure for efficient word storage and retrieval.,class TrieNode { constructor() { this.children = {}; this.isEndOfWord = false; } } class Trie { constructor() { this.root = new TrieNode(); } insert(word) { let node = this.root; for (let char of word) { if (!node.children[char]) { node.children[char] = new TrieNode(); } node = node.children[char]; } node.isEndOfWord = true; } },Useful
Performs in-order traversal of a binary tree.,def binary_tree_inorder(node): return binary_tree_inorder(node.left) + [node.value] + binary_tree_inorder(node.right) if node else [],Useful
Counts the number of vowels in a given string.,function countVowels(str) { return str.match(/[aeiou]/gi)?.length || 0; },Useful
This function implements the merge sort algorithm to sort an array.,def merge_sort(arr): if len(arr) > 1: mid = len(arr) // 2; L = arr[:mid]; R = arr[mid:]; merge_sort(L); merge_sort(R); i = j = k = 0; while i < len(L) and j < len(R): if L[i] < R[j]: arr[k] = L[i]; i += 1; else: arr[k] = R[j]; j += 1; k += 1; while i < len(L): arr[k] = L[i]; i += 1; k += 1; while j < len(R): arr[k] = R[j]; j += 1; k += 1,Useful
This class is for creating a graph.,"class Graph: def __init__(self): self.vertices = {}; def add_vertex(self, vertex): self.vertices[vertex] = []; def add_edge(self, vertex1, vertex2): self.vertices[vertex1].append(vertex2); self.vertices[vertex2].append(vertex1)",Not Useful
This function helps in limiting the rate at which a function can fire.,"function debounce(func, delay) { let timeout; return function(...args) { const context = this; clearTimeout(timeout); timeout = setTimeout(() => func.apply(context, args), delay); }; }",Useful
This function reverses a linked list.,struct Node { int data; Node* next; }; Node* reverse(Node* head) { Node* prev = nullptr; Node* current = head; Node* next = nullptr; while (current != nullptr) { next = current->next; current->next = prev; prev = current; current = next; } return prev; },Useful
Calculates the Fibonacci number recursively.,"pub fn fibonacci(n: u32) -> u32 { match n { 0 => 0, 1 => 1, _ => fibonacci(n - 1) + fibonacci(n - 2), } }",Useful
Checks if two strings are anagrams.,"def is_anagram(str1, str2): return sorted(str1) == sorted(str2)",Useful
This function sorts an array using the quicksort algorithm.,"function quickSort(arr) { if (arr.length <= 1) return arr; let pivot = arr[arr.length - 1]; let left = [], right = []; for (let i = 0; i < arr.length - 1; i++) { if (arr[i] < pivot) left.push(arr[i]); else right.push(arr[i]); } return [...quickSort(left), pivot, ...quickSort(right)]; }",Useful
This class models a user with a username and password.,"class User: def __init__(self, username, password): self.username = username; self.password = password; def check_password(self, password): return self.password == password",Not Useful
This function implements Dijkstra's algorithm to find the shortest path in a weighted graph.,"def dijkstra(graph, start): shortest_path = {vertex: float('infinity') for vertex in graph}; shortest_path[start] = 0; priority_queue = [(0, start)]; while priority_queue: current_distance, current_vertex = heapq.heappop(priority_queue); for neighbor, weight in graph[current_vertex].items(): distance = current_distance + weight; if distance < shortest_path[neighbor]: shortest_path[neighbor] = distance; heapq.heappush(priority_queue, (distance, neighbor)); return shortest_path",Useful
Performs a binary search on a sorted array.,"fn binary_search(arr: &[i32], target: i32) -> Option<usize> { let mut left = 0; let mut right = arr.len(); while left < right { let mid = left + (right - left) / 2; if arr[mid] == target { return Some(mid); } else if arr[mid] < target { left = mid + 1; } else { right = mid; } } None }",Useful
Counts the number of vowels in a string.,def count_vowels(s): return sum(1 for char in s if char.lower() in 'aeiou'),Useful
This class represents a car.,"class Car: def __init__(self, make, model, year): self.make = make; self.model = model; self.year = year; def display_info(self): return f'{self.year} {self.make} {self.model}'",Not Useful
This function fetches data from a URL.,function fetchData(url) { return fetch(url).then(response => response.json()).then(data => console.log(data)); },Not Useful
Calculates Fibonacci numbers using iteration.,"def fibonacci_iter(n): a, b = 0, 1; for _ in range(n): a, b = b, a + b; return a",Useful
This class implements a stack data structure.,"class Stack: def __init__(self): self.items = []; def push(self, item): self.items.append(item); def pop(self): return self.items.pop() if not self.is_empty() else None; def is_empty(self): return len(self.items) == 0",Not Useful
Merges two sorted arrays into one.,"function merge(arr1, arr2) { let merged = []; let i = 0; let j = 0; while (i < arr1.length && j < arr2.length) { if (arr1[i] < arr2[j]) { merged.push(arr1[i++]); } else { merged.push(arr2[j++]); } } return merged.concat(arr1.slice(i)).concat(arr2.slice(j)); }",Useful
Checks if a number is prime.,"def is_prime(num): if num < 2: return False; for i in range(2, int(num**0.5) + 1): if num % i == 0: return False; return True",Useful
Calculates the greatest common divisor using recursion.,"fn gcd(a: u32, b: u32) -> u32 { if b == 0 { a } else { gcd(b, a % b) } }",Useful
This class converts Celsius to Fahrenheit.,"class Temperature: def __init__(self, celsius): self.celsius = celsius; def to_fahrenheit(self): return (self.celsius * 9 / 5) + 32",Not Useful
This function checks if a string is a palindrome.,function is_palindrome(str) { return str === str.split('').reverse().join(''); },Useful
Searches for a value in a binary tree.,"def binary_tree_search(node, target): if node is None: return False; if node.value == target: return True; return binary_tree_search(node.left, target) or binary_tree_search(node.right, target)",Useful
This class defines a linked list.,"class LinkedList: def __init__(self): self.head = None; def append(self, data): new_node = Node(data); if self.head is None: self.head = new_node; else: last = self.head; while last.next: last = last.next; last.next = new_node",Not Useful
Computes the factorial of a number.,function factorial(n) { if (n === 0) return 1; return n * factorial(n - 1); },Useful
This function sorts an array using the merge sort algorithm.,"pub fn merge_sort<T: Ord>(arr: &mut [T]) { let mid = arr.len() / 2; if mid == 0 { return; } merge_sort(&mut arr[0..mid]); merge_sort(&mut arr[mid..]); let mut merged = Vec::with_capacity(arr.len()); let (mut left, mut right) = (0, mid); while left < mid && right < arr.len() { if arr[left] <= arr[right] { merged.push(arr[left]); left += 1; } else { merged.push(arr[right]); right += 1; } } merged.extend_from_slice(&arr[left..mid]); merged.extend_from_slice(&arr[right..]); arr.copy_from_slice(&merged); }",Useful
Finds two indices of numbers in an array that add up to the target.,"def two_sum(nums, target): num_map = {}; for i, num in enumerate(nums): complement = target - num; if complement in num_map: return [num_map[complement], i]; num_map[num] = i",Useful
This class implements a queue data structure.,"class Queue: def __init__(self): self.items = []; def enqueue(self, item): self.items.append(item); def dequeue(self): return self.items.pop(0) if not self.is_empty() else None; def is_empty(self): return len(self.items) == 0",Not Useful
Removes duplicate values from an array.,function remove_duplicates(arr) { return [...new Set(arr)]; },Useful
Flattens a nested list into a single list.,def flatten(lst): return [item for sublist in lst for item in sublist],Useful
Counts the occurrences of each word in a string.,"pub fn count_words(s: &str) -> HashMap<&str, usize> { let mut word_count = HashMap::new(); for word in s.split_whitespace() { *word_count.entry(word).or_insert(0) += 1; } word_count }",Useful
Finds the longest common prefix string amongst an array of strings.,def longest_common_prefix(strs): if not strs: return ''; prefix = strs[0]; for s in strs[1:]: while s[:len(prefix)] != prefix and prefix: prefix = prefix[:-1]; return prefix,Useful
Generates a Fibonacci sequence up to n.,"function generate_fibonacci(n) { let fib = [0, 1]; for (let i = 2; i < n; i++) { fib[i] = fib[i - 1] + fib[i - 2]; } return fib; }",Useful
Performs a binary search recursively.,"def binary_search_recursive(arr, target, low, high): if low > high: return -1; mid = (low + high) // 2; if arr[mid] == target: return mid; elif arr[mid] < target: return binary_search_recursive(arr, target, mid + 1, high); else: return binary_search_recursive(arr, target, low, mid - 1)",Useful
This class defines a person with a name and age.,"class Person: def __init__(self, name, age): self.name = name; self.age = age; def birthday(self): self.age += 1",Not Useful
Counts down from n to 1.,function count_down(n) { while (n > 0) { console.log(n); n--; } },Not Useful
Rotates the elements of the array to the right by k steps.,"def rotate_array(arr, k): k = k % len(arr); return arr[-k:] + arr[:-k]",Useful
Calculates the nth Fibonacci number using an iterative approach.,"def fibonacci(n): a, b = 0, 1; for _ in range(n): a, b = b, a + b; return a",Useful
This class represents a graph.,"class Graph: def __init__(self): self.edges = {}; def add_edge(self, u, v): if u not in self.edges: self.edges[u] = []; self.edges[u].append(v)",Not Useful
This function sorts an array.,"function mergeSort(arr) { if (arr.length <= 1) return arr; const mid = Math.floor(arr.length / 2); const left = mergeSort(arr.slice(0, mid)); const right = mergeSort(arr.slice(mid)); return merge(left, right); }",Not Useful
Defines a linked list node and its associated list methods.,"struct Node { int data; Node* next; Node(int val) : data(val), next(nullptr) {} }; class LinkedList { Node* head; public: LinkedList() : head(nullptr) {} void append(int val) { Node* newNode = new Node(val); if (!head) { head = newNode; return; } Node* temp = head; while (temp->next) { temp = temp->next; } temp->next = newNode; }};",Useful
This function fetches data from a given URL and returns it as JSON.,async function fetchData(url) { const response = await fetch(url); if (!response.ok) throw new Error('Network response was not ok'); const data = await response.json(); return data; },Useful
This struct defines a Point in 2D space with methods for instantiation and distance calculation.,"pub struct Point { pub x: f64, pub y: f64 } impl Point { pub fn new(x: f64, y: f64) -> Point { Point { x, y } } pub fn distance(&self, other: &Point) -> f64 { ((self.x - other.x).powi(2) + (self.y - other.y).powi(2)).sqrt() } }",Useful
Performs a binary search on sorted array to find the index of the target value.,"def binary_search(arr, target): low, high = 0, len(arr) - 1; while low <= high: mid = (low + high) // 2; if arr[mid] == target: return mid; elif arr[mid] < target: low = mid + 1; else: high = mid - 1; return -1",Useful
This class implements a queue data structure.,class Queue { constructor() { this.items = []; } enqueue(element) { this.items.push(element); } dequeue() { return this.items.shift(); } isEmpty() { return this.items.length == 0; } },Useful
Checks if a given number is prime.,"def is_prime(num): if num < 2: return False; for i in range(2, int(num ** 0.5) + 1): if num % i == 0: return False; return True",Useful
Implements the quicksort algorithm to sort an array in place.,pub fn quicksort(arr: &mut [i32]) { if arr.len() <= 1 { return; } let pivot_index = partition(arr); quicksort(&mut arr[0..pivot_index]); quicksort(&mut arr[pivot_index + 1..]); },Useful
Creates a debounced function that delays invoking func until after wait milliseconds.,"function debounce(func, wait) { let timeout; return function(...args) { const context = this; clearTimeout(timeout); timeout = setTimeout(() => func.apply(context, args), wait); }; }",Useful
Defines a binary tree node and structure.,"class TreeNode { int val; TreeNode* left; TreeNode* right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; class BinaryTree { TreeNode* root; public: void insert(int val) { // TODO: Implement insertion logic } }",Not Useful
This function checks if two strings are anagrams.,"def anagram_check(str1, str2): return sorted(str1) == sorted(str2)",Useful
Limits the rate at which a function can be called.,"function throttle(func, limit) { let lastFunc; let lastRan; return function() { const context = this; const args = arguments; if (!lastRan) { func.apply(context, args); lastRan = Date.now(); } else { clearTimeout(lastFunc); lastFunc = setTimeout(function() { if ((Date.now() - lastRan) >= limit) { func.apply(context, args); lastRan = Date.now(); } }, limit - (Date.now() - lastRan)); } }; }",Useful
Merges two dictionaries into one.,"def merge_dicts(dict1, dict2): return {**dict1, **dict2}",Useful
Handles GET requests in a simple HTTP server.,"class SimpleHTTPServer: def do_GET(self): self.send_response(200); self.send_header('Content-type', 'text/html'); self.end_headers(); self.wfile.write(b'Hello, World!')",Useful
Calculates the factorial of a number using an iterator.,pub fn factorial(n: u64) -> u64 { (1..=n).product() },Useful
Calculates the length of the longest common subsequence between two strings.,"def longest_common_subsequence(str1, str2): dp = [[0] * (len(str2) + 1) for _ in range(len(str1) + 1)]; for i in range(1, len(str1) + 1): for j in range(1, len(str2) + 1): if str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1; else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); return dp[-1][-1]",Useful
Makes an AJAX GET request to the specified URL.,"function ajaxGet(url) { const xhr = new XMLHttpRequest(); xhr.open('GET', url); xhr.onload = function() { if (xhr.status >= 200 && xhr.status < 400) { console.log(xhr.responseText); } }; xhr.send(); }",Useful
Implements a generic stack data structure.,template <typename T> class Stack { private: std::vector<T> elements; public: void push(const T& element) { elements.push_back(element); } T pop() { if (elements.empty()) throw std::out_of_range('Stack<>::pop(): empty stack!'); T elem = elements.back(); elements.pop_back(); return elem; } };,Useful
Rotates a square matrix 90 degrees clockwise.,"def rotate_matrix(matrix): n = len(matrix); for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]; matrix.reverse()",Useful
Defines a User class and prints user information.,"class User { public: string name; int age; User(string n, int a) : name(n), age(a) {} }; vector<User> users; for (auto& user : users) { cout << user.name << ' ' << user.age; }",Not Useful
"Sorts a list of tuples based on the second element, then the first.","def custom_sort(arr): return sorted(arr, key=lambda x: (x[1], x[0]))",Useful
Implements the observer pattern for a subject.,class Subject { private: string name; vector<Observer*> observers; public: void attach(Observer* obs) { observers.push_back(obs); } void notify() { for (Observer* obs : observers) obs->update(); } };,Useful
Counts the number of vowels in a given string.,def count_vowels(s): return sum(1 for char in s if char in 'aeiouAEIOU'),Useful
Creates a reducer function for state management.,"function createReducer(reducer, initialState) { return function(state, action) { const nextState = reducer(state, action); return nextState !== undefined ? nextState : state; }; }",Useful
Sorts an array using the merge sort algorithm.,"pub fn merge_sort<T: Ord>(arr: &mut [T]) { let mid = arr.len() / 2; if mid == 0 { return; } let left = &mut arr[..mid]; let right = &mut arr[mid..]; merge_sort(left); merge_sort(right); merge(left, right); }",Useful
Returns a list of unique elements from the input list.,def unique_elements(lst): return list(set(lst)),Useful
Defines a database class with connection methods.,class Database { public: void connect(); void disconnect(); }; void Database::connect() { // Connection logic here },Not Useful
Flattens a nested list into a single list.,def flatten(nested_list): return [item for sublist in nested_list for item in sublist],Useful
Calculates the height of a binary tree.,"pub fn binary_tree_height(node: Option<Box<TreeNode>>) -> usize { match node { Some(n) => 1 + max(binary_tree_height(n.left), binary_tree_height(n.right)), None => 0 } }",Useful
Generates all permutations of a given list.,def generate_permutations(arr): if len(arr) == 0: return [[]]; return [[arr[i]] + p for i in range(len(arr)) for p in generate_permutations(arr[:i] + arr[i+1:])],Useful
Validates if a string is a proper email format.,function validateEmail(email) { const regex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/; return regex.test(email); },Useful
Implements an LRU cache decorator for function results.,def lru_cache(max_size): def decorator(func): cache = {} def wrapper(*args): if args in cache: return cache[args]; if len(cache) >= max_size: cache.popitem(last=False); cache[args] = func(*args); return cache[args]; return wrapper; return decorator,Useful
Finds the maximum value in an array.,pub fn find_max(arr: &[i32]) -> i32 { *arr.iter().max().unwrap() },Useful
This function implements the quicksort algorithm which sorts an array by selecting a pivot and partitioning the array.,def quicksort(arr): if len(arr) <= 1: return arr else: pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quicksort(left) + middle + quicksort(right),Useful
This function merges two sorted arrays into a single sorted array.,"const mergeSortedArrays = (arr1, arr2) => { let merged = []; let i = 0; let j = 0; while (i < arr1.length && j < arr2.length) { if (arr1[i] < arr2[j]) { merged.push(arr1[i++]); } else { merged.push(arr2[j++]); } } return merged.concat(arr1.slice(i)).concat(arr2.slice(j)); };",Useful
This class represents a graph data structure and allows adding edges between vertices.,"class Graph: def __init__(self): self.vertices = {} def add_edge(self, v1, v2): if v1 not in self.vertices: self.vertices[v1] = [] self.vertices[v1].append(v2)",Useful
This function fetches data from a given URL asynchronously and handles errors related to the network response.,async function fetchData(url) { const response = await fetch(url); if (!response.ok) throw new Error('Network response was not ok'); const data = await response.json(); return data; },Useful
This struct defines a node in a binary tree with integer value and pointers to left and right child nodes.,"struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} };",Useful
This function calculates the nth Fibonacci number using an iterative approach.,"def fibonacci(n): a, b = 0, 1 for _ in range(n): a, b = b, a + b return a",Useful
This class implements a singly linked list with a method to append new nodes at the end.,"class LinkedList: def __init__(self): self.head = None def append(self, data): new_node = Node(data) if not self.head: self.head = new_node return current = self.head while current.next: current = current.next current.next = new_node",Useful
This function performs a binary search on a sorted array to find the index of the target value.,"def binary_search(arr, target): low, high = 0, len(arr) - 1 while low <= high: mid = (low + high) // 2 if arr[mid] < target: low = mid + 1 elif arr[mid] > target: high = mid - 1 else: return mid return -1",Useful
This class represents a vehicle with a specific number of wheels and a method to retrieve that number.,"class Vehicle: def __init__(self, wheels): self.wheels = wheels def get_wheels(self): return self.wheels",Useful
This function checks if a given string is a palindrome by comparing it to its reverse.,def is_palindrome(s): return s == s[::-1],Useful
This function sends a POST request to a specified URL with JSON data and returns the response.,"async function postData(url = '', data = {}) { const response = await fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(data) }); return response.json(); }",Useful
This template class implements a stack data structure with push and pop operations.,template <typename T> class Stack { private: vector<T> elements; public: void push(const T& element) { elements.push_back(element); } T pop() { if (elements.empty()) throw out_of_range('Stack<>::pop(): empty stack'); T elem = elements.back(); elements.pop_back(); return elem; } };,Useful
This function implements the merge sort algorithm to sort an array by recursively dividing it into halves.,"def merge_sort(arr): if len(arr) <= 1: return arr mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half)",Useful
This function creates a debounced version of a function that delays its execution until after a specified delay.,"function debounce(func, delay) { let timeout; return function(...args) { const context = this; clearTimeout(timeout); timeout = setTimeout(() => func.apply(context, args), delay); }; }",Useful
This class maintains a count and provides methods to increment and retrieve the count value.,class Counter: def __init__(self): self.count = 0 def increment(self): self.count += 1 def get_count(self): return self.count,Useful
This function implements Kadane's algorithm to find the maximum sum of a contiguous subarray.,"def find_max_subarray(arr): max_sum = current_sum = arr[0] for num in arr[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum",Useful
This class represents a matrix and provides a method to compute its transpose.,"class Matrix: def __init__(self, data): self.data = data def transpose(self): return [[self.data[j][i] for j in range(len(self.data))] for i in range(len(self.data[0]))]",Useful
This function performs depth-first search on a graph starting from a given vertex.,"def depth_first_search(graph, start): visited, stack = set(), [start] while stack: vertex = stack.pop() if vertex not in visited: visited.add(vertex) stack.extend(set(graph[vertex]) - visited) return visited",Useful
This class represents a user with a username and email and provides a string representation.,"class User: def __init__(self, username, email): self.username = username self.email = email def __str__(self): return f'User: {self.username}, Email: {self.email}'",Useful
This function calculates the angle between the hour and minute hands of a clock.,"def clock_angle(hour, minute): hour_angle = (hour % 12 + minute / 60) * 30 minute_angle = minute * 6 return abs(hour_angle - minute_angle)",Useful
This class implements a queue data structure with enqueue and dequeue operations.,"class Queue: def __init__(self): self.items = [] def enqueue(self, item): self.items.insert(0, item) def dequeue(self): return self.items.pop()",Useful
This function computes the prime factors of a given number using trial division.,"def prime_factors(n): factors = [] for i in range(2, int(n**0.5) + 1): while n % i == 0: factors.append(i) n //= i if n > 1: factors.append(n) return factors",Useful
This function loads data from a URL and parses it as CSV format.,async function loadAndParse(url) { const response = await fetch(url); const text = await response.text(); return parseCSV(text); },Useful
This class hierarchy defines a base Shape class and a Rectangle class that calculates its area.,"class Shape: def area(self): pass class Rectangle(Shape): def __init__(self, width, height): self.width = width self.height = height def area(self): return self.width * self.height",Useful
This function rotates an array to the right by k steps in-place.,"def rotate_array(arr, k): n = len(arr) k = k % n arr[:] = arr[-k:] + arr[:-k]",Useful
"This class manages file operations, including reading the contents of a file.","class FileManager: def __init__(self, filename): self.filename = filename def read(self): with open(self.filename, 'r') as file: return file.read()",Useful
This function finds the longest common prefix string among an array of strings.,def longest_common_prefix(strs): if not strs: return '' prefix = strs[0] for s in strs[1:]: while s[:len(prefix)] != prefix and prefix: prefix = prefix[:-1] return prefix,Useful
This code demonstrates inheritance where Dog class inherits from Animal class and overrides the speak method.,class Animal: def speak(self): pass class Dog(Animal): def speak(self): return 'Woof!',Useful
This function calculates the final price after applying a discount percentage.,"def calculate_discount(price, discount): return price - (price * discount / 100)",Useful
This function flattens a nested array into a single array.,"function flatten(arr) { return arr.reduce((flat, toFlatten) => flat.concat(Array.isArray(toFlatten) ? flatten(toFlatten) : toFlatten), []); }",Useful
This function counts the number of words in a given string by splitting it.,def count_words(s): return len(s.split()),Useful
This class represents a bank account with methods for depositing and withdrawing funds.,"class BankAccount: def __init__(self, balance): self.balance = balance def deposit(self, amount): self.balance += amount def withdraw(self, amount): if amount > self.balance: raise ValueError('Insufficient funds') self.balance -= amount",Useful
This function computes the greatest common divisor of two integers using the Euclidean algorithm.,"def gcd(a, b): while b: a, b = b, a % b return a",Useful
"This class represents a person with a name and age, and provides a method to increment their age.","class Person: def __init__(self, name, age): self.name = name self.age = age def birthday(self): self.age += 1",Useful
This function checks if a string has valid parentheses by using a stack.,def valid_parentheses(s): stack = [] for char in s: if char in '(': stack.append(char) elif char in ')': if not stack: return False stack.pop() return not stack,Useful
This function implements the 0/1 Knapsack problem using dynamic programming to maximize the value that can be carried within a given capacity.,"def knapsack(weights, values, capacity): n = len(values) dp = [[0 for _ in range(capacity + 1)] for _ in range(n + 1)] for i in range(n + 1): for w in range(capacity + 1): if i == 0 or w == 0: dp[i][w] = 0 elif weights[i-1] <= w: dp[i][w] = max(values[i-1] + dp[i-1][w - weights[i-1]], dp[i-1][w]) else: dp[i][w] = dp[i-1][w] return dp[n][capacity]",Useful
This class represents a directed graph and contains methods to add edges and perform breadth-first search.,"class Graph: def __init__(self): self.graph = {} def add_edge(self, u, v): if u not in self.graph: self.graph[u] = [] self.graph[u].append(v) def bfs(self, start): visited = set() queue = [start] while queue: vertex = queue.pop(0) if vertex not in visited: visited.add(vertex) queue.extend(set(self.graph[vertex]) - visited)",Useful
"This function sorts an array using the merge sort algorithm, which is a divide-and-conquer sorting technique.","function mergeSort(arr) { if (arr.length < 2) return arr; const mid = Math.floor(arr.length / 2); const left = mergeSort(arr.slice(0, mid)); const right = mergeSort(arr.slice(mid)); return merge(left, right); } function merge(left, right) { let result = [], i = 0, j = 0; while (i < left.length && j < right.length) { if (left[i] < right[j]) result.push(left[i++]); else result.push(right[j++]); } return result.concat(left.slice(i)).concat(right.slice(j)); }",Useful
This code defines a binary tree in C++ with an insert method to add nodes while maintaining the properties of the binary search tree.,"struct Node { int data; Node* left; Node* right; Node(int val) : data(val), left(nullptr), right(nullptr) {} }; class BinaryTree { public: Node* root; BinaryTree() : root(nullptr) {} void insert(int val) { root = insertRec(root, val); } private: Node* insertRec(Node* node, int val) { if (node == nullptr) return new Node(val); if (val < node->data) node->left = insertRec(node->left, val); else node->right = insertRec(node->right, val); return node; }};",Useful
"This implementation of a queue uses two stacks to manage elements, allowing for standard queue operations like push and pop.","impl MyQueue { stack: Vec<i32>, temp_stack: Vec<i32> } impl MyQueue { fn new() -> Self { MyQueue { stack: Vec::new(), temp_stack: Vec::new() } } fn push(&mut self, x: i32) { self.stack.push(x); } fn pop(&mut self) -> i32 { while let Some(val) = self.stack.pop() { self.temp_stack.push(val); } let front = self.temp_stack.pop().unwrap(); while let Some(val) = self.temp_stack.pop() { self.stack.push(val); } front } fn peek(&self) -> i32 { *self.stack.last().unwrap() } fn empty(&self) -> bool { self.stack.is_empty() }}",Useful
This code defines an LRU (Least Recently Used) cache decorator to optimize function calls by caching results.,def lru_cache(maxsize=128): def decorator(func): cache = {} def wrapper(*args): if args in cache: return cache[args] if len(cache) >= maxsize: cache.popitem() cache[args] = func(*args) return cache[args] return wrapper return decorator,Useful
"This function creates a debounced version of the provided function, ensuring that it can only be called after a specified delay.","function debounce(func, wait) { let timeout; return function(...args) { const context = this; clearTimeout(timeout); timeout = setTimeout(() => func.apply(context, args), wait); }; }",Useful
This code finds the longest common prefix among a list of strings using a character-by-character comparison.,"class Solution: def longestCommonPrefix(self, strs: List[str]) -> str: if not strs: return '' prefix = strs[0] for s in strs[1:]: while not s.startswith(prefix): prefix = prefix[:-1] if not prefix: return '' return prefix",Useful
"This function implements the quicksort algorithm, which sorts an array by selecting a pivot and partitioning the array.",def quicksort(arr): if len(arr) <= 1: return arr pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quicksort(left) + middle + quicksort(right),Useful
"This class represents a circular queue with methods to add and remove elements, handling wrap-around efficiently.","class CircularQueue: def __init__(self, size): self.size = size self.queue = [None] * size self.front = self.rear = -1 def enqueue(self, item): if (self.rear + 1) % self.size == self.front: raise Exception('Queue is full') if self.front == -1: self.front = 0 self.rear = (self.rear + 1) % self.size self.queue[self.rear] = item def dequeue(self): if self.front == -1: raise Exception('Queue is empty') item = self.queue[self.front] if self.front == self.rear: self.front = self.rear = -1 else: self.front = (self.front + 1) % self.size return item",Useful
This function calculates the nth Fibonacci number using an iterative approach and stores previously computed values.,"const fibonacci = (n) => { const fib = [0, 1]; for (let i = 2; i <= n; i++) { fib[i] = fib[i - 1] + fib[i - 2]; } return fib[n]; };",Useful
This function performs a binary search on a sorted array to find the index of a target value.,"def binary_search(arr, target): low, high = 0, len(arr) - 1 while low <= high: mid = (low + high) // 2 if arr[mid] < target: low = mid + 1 elif arr[mid] > target: high = mid - 1 else: return mid return -1",Useful
"This class implements an AVL tree, a self-balancing binary search tree, with methods to insert nodes and maintain balance.","class AVLTree: def __init__(self): self.root = None def insert(self, key): self.root = self._insert(self.root, key) def _insert(self, node, key): if not node: return Node(key) if key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) return self._balance(node)",Useful
"This function limits the rate at which a function can be called, ensuring it doesn't exceed the specified limit.","function throttle(func, limit) { let lastFunc; let lastRan; return function() { const context = this; const args = arguments; if (!lastRan) { func.apply(context, args); lastRan = Date.now(); } else { clearTimeout(lastFunc); lastFunc = setTimeout(() => { if ((Date.now() - lastRan) >= limit) { func.apply(context, args); lastRan = Date.now(); } }, limit - (Date.now() - lastRan)); } }; }",Useful
This function merges two sorted lists into a single sorted list by iterating through both lists simultaneously.,"def merge_sorted_lists(list1, list2): merged = [] i, j = 0, 0 while i < len(list1) and j < len(list2): if list1[i] < list2[j]: merged.append(list1[i]) i += 1 else: merged.append(list2[j]) j += 1 merged.extend(list1[i:]) merged.extend(list2[j:]) return merged",Useful
This class implements a max heap with methods to insert elements and maintain the heap property.,"class MaxHeap: def __init__(self): self.heap = [] def insert(self, val): self.heap.append(val) self._heapify_up(len(self.heap) - 1) def _heapify_up(self, index): while index > 0: parent = (index - 1) // 2 if self.heap[parent] < self.heap[index]: self.heap[parent], self.heap[index] = self.heap[index], self.heap[parent] index = parent else: break",Useful
This function checks if a given string is a palindrome by comparing it with its reversed version.,function isPalindrome(str) { const reversed = str.split('').reverse().join(''); return str === reversed; },Useful
This function generates the power set of a given set using recursion to build all possible subsets.,def power_set(s): if not s: return [[]] res = power_set(s[:-1]) return res + [r + [s[-1]] for r in res],Useful
This function finds all start indices of anagrams of a given string within another string using character counting.,"const findAnagrams = (s, p) => { const result = []; const pCount = Array(26).fill(0); for (let char of p) { pCount[char.charCodeAt(0) - 'a'.charCodeAt(0)]++; } for (let i = 0; i < s.length - p.length + 1; i++) { const sCount = Array(26).fill(0); for (let j = 0; j < p.length; j++) { sCount[s[i + j].charCodeAt(0) - 'a'.charCodeAt(0)]++; } if (JSON.stringify(sCount) === JSON.stringify(pCount)) result.push(i); } return result; };",Useful
"This code defines a trie data structure for efficient word storage and retrieval, allowing for prefix-based searches.","class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True",Useful
This function recursively flattens a nested array into a single-level array using reduce.,"function flattenArray(arr) { return arr.reduce((flat, toFlatten) => flat.concat(Array.isArray(toFlatten) ? flattenArray(toFlatten) : toFlatten), []); }",Useful
This function implements Dijkstra's algorithm to find the shortest paths from a starting node to all other nodes in a weighted graph.,"def dijkstra(graph, start): shortest_paths = {node: float('infinity') for node in graph} shortest_paths[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) for neighbor, weight in graph[current_node].items(): distance = current_distance + weight if distance < shortest_paths[neighbor]: shortest_paths[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return shortest_paths",Useful
This class implements a segment tree for efficient range queries and updates over an array.,"class SegmentTree: def __init__(self, data): self.n = len(data) self.tree = [0] * (2 * self.n) self.build(data) def build(self, data): for i in range(self.n): self.tree[self.n + i] = data[i] for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[2 * i] + self.tree[2 * i + 1]",Useful
This function rotates a square matrix 90 degrees clockwise in place.,function rotateMatrix(matrix) { let n = matrix.length; for (let layer = 0; layer < n / 2; layer++) { let first = layer; let last = n - 1 - layer; for (let i = first; i < last; i++) { let offset = i - first; let top = matrix[first][i]; matrix[first][i] = matrix[last - offset][first]; matrix[last - offset][first] = matrix[last][last - offset]; matrix[last][last - offset] = matrix[i][last]; matrix[i][last] = top; } } return matrix; },Useful
This function checks if a string has balanced parentheses using a stack to track opening and closing brackets.,def is_balanced_parentheses(s): stack = [] for char in s: if char == '(': stack.append(char) elif char == ')': if not stack: return False stack.pop() return not stack,Useful
This class implements a singly linked list with methods to insert new nodes and display the list.,"class LinkedList: class Node: def __init__(self, data): self.data = data self.next = None def __init__(self): self.head = None def insert(self, data): new_node = self.Node(data) new_node.next = self.head self.head = new_node def display(self): current = self.head while current: print(current.data) current = current.next",Useful
This function finds two indices in an array that add up to a specified target using a hash map for fast lookups.,"const twoSum = (nums, target) => { const map = new Map(); for (let i = 0; i < nums.length; i++) { const complement = target - nums[i]; if (map.has(complement)) { return [map.get(complement), i]; } map.set(nums[i], i); } return []; };",Useful
This function finds all combinations of numbers that sum up to a target value using backtracking.,"def combination_sum(candidates, target): def backtrack(start, target, path): if target == 0: res.append(path) return if target < 0: return for i in range(start, len(candidates)): backtrack(i, target - candidates[i], path + [candidates[i]]) res = [] backtrack(0, target, []) return res",Useful
This class implements an LRU (Least Recently Used) cache that supports get and put operations with a fixed capacity.,"class LRUCache: def __init__(self, capacity: int): self.cache = {} self.capacity = capacity self.order = [] def get(self, key: int) -> int: if key not in self.cache: return -1 self.order.remove(key) self.order.append(key) return self.cache[key] def put(self, key: int, value: int) -> None: if key in self.cache: self.order.remove(key) else: if len(self.cache) >= self.capacity: lru = self.order.pop(0) del self.cache[lru] self.cache[key] = value self.order.append(key)",Useful
This function calculates the largest rectangle area in a histogram using a stack to track indices.,"def largest_rectangle_area(heights): stack, max_area = [], 0 for i, h in enumerate(heights): while stack and heights[stack[-1]] > h: height = heights[stack.pop()] width = i if not stack else i - stack[-1] - 1 max_area = max(max_area, height * width) stack.append(i) while stack: height = heights[stack.pop()] width = len(heights) if not stack else len(heights) - stack[-1] - 1 max_area = max(max_area, height * width) return max_area",Useful
This function finds the maximum sum of a contiguous subarray using Kadane's algorithm.,"const maxSubArray = (nums) => { let max = nums[0], currentMax = nums[0]; for (let i = 1; i < nums.length; i++) { currentMax = Math.max(nums[i], currentMax + nums[i]); max = Math.max(max, currentMax); } return max; };",Useful
This function finds the median of two sorted arrays using a binary search approach for efficiency.,"def findMedianSortedArrays(nums1, nums2): def get_kth(k): i, j = 0, 0 while True: if i == len(nums1): return nums2[j + k - 1] if j == len(nums2): return nums1[i + k - 1] if k == 1: return min(nums1[i], nums2[j]) mid1, mid2 = (i + k // 2 - 1), (j + k // 2 - 1) val1 = nums1[mid1] if mid1 < len(nums1) else float('inf') val2 = nums2[mid2] if mid2 < len(nums2) else float('inf') if val1 < val2: i += k // 2 else: j += k // 2 k -= k // 2 return get_kth((len(nums1) + len(nums2) + 1) // 2)",Useful
This class generates all permutations of a list of numbers using backtracking.,"class Permutation: def __init__(self): self.permutations = [] def permute(self, nums): self._backtrack(nums, []) return self.permutations def _backtrack(self, nums, path): if not nums: self.permutations.append(path) for i in range(len(nums)): self._backtrack(nums[:i] + nums[i+1:], path + [nums[i]])",Useful
This function checks if two strings are anagrams by counting character occurrences in both strings.,"const isAnagram = (s, t) => { if (s.length !== t.length) return false; const count = {}; for (let char of s) { count[char] = (count[char] || 0) + 1; } for (let char of t) { if (!count[char]) return false; count[char]--; } return true; };",Useful
This function generates all combinations of well-formed parentheses for a given number of pairs using backtracking.,"def generate_parentheses(n): def backtrack(s='', left=0, right=0): if len(s) == 2 * n: res.append(s) return if left < n: backtrack(s + '(', left + 1, right) if right < left: backtrack(s + ')', left, right + 1) res = [] backtrack() return res",Useful
This function generates a Fibonacci sequence up to n terms.,"def fibonacci(n):
    if n <= 0:
        return []
    elif n == 1:
        return [0]
    elif n == 2:
        return [0, 1]
    else:
        fib_seq = [0, 1]
        for i in range(2, n):
            fib_seq.append(fib_seq[-1] + fib_seq[-2])
        return fib_seq",Useful
This class defines a binary tree structure.,"class Node:
    def __init__(self, key):
        self.left = None
        self.right = None
        self.value = key

class BinaryTree:
    def __init__(self):
        self.root = None

    def insert(self, key):
        if self.root is None:
            self.root = Node(key)
        else:
            self._insert_recursively(self.root, key)

    def _insert_recursively(self, current_node, key):
        if key < current_node.value:
            if current_node.left is None:
                current_node.left = Node(key)
            else:
                self._insert_recursively(current_node.left, key)
        else:
            if current_node.right is None:
                current_node.right = Node(key)
            else:
                self._insert_recursively(current_node.right, key)",Useful
This function sorts an array using the merge sort algorithm.,"def merge_sort(arr):
    if len(arr) > 1:
        mid = len(arr) // 2
        left_half = arr[:mid]
        right_half = arr[mid:]

        merge_sort(left_half)
        merge_sort(right_half)

        i = j = k = 0

        while i < len(left_half) and j < len(right_half):
            if left_half[i] < right_half[j]:
                arr[k] = left_half[i]
                i += 1
            else:
                arr[k] = right_half[j]
                j += 1
            k += 1

        while i < len(left_half):
            arr[k] = left_half[i]
            i += 1
            k += 1

        while j < len(right_half):
            arr[k] = right_half[j]
            j += 1
            k += 1",Useful
This function performs the quicksort algorithm on an array.,"function quickSort(arr) {
    if (arr.length <= 1) {
        return arr;
    }
    const pivot = arr[arr.length - 1];
    const left = [];
    const right = [];
    for (let i = 0; i < arr.length - 1; i++) {
        if (arr[i] < pivot) {
            left.push(arr[i]);
        } else {
            right.push(arr[i]);
        }
    }
    return [...quickSort(left), pivot, ...quickSort(right)];
}",Useful
This function implements binary search for a sorted array.,"pub fn binary_search<T: Ord>(arr: &[T], target: T) -> Option<usize> {
    let mut left = 0;
    let mut right = arr.len();

    while left < right {
        let mid = left + (right - left) / 2;
        if arr[mid] == target {
            return Some(mid);
        } else if arr[mid] < target {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    None
}",Useful
This class represents a directed graph and implements depth-first search.,"class Graph:
    def __init__(self):
        self.graph = {}

    def add_edge(self, u, v):
        if u not in self.graph:
            self.graph[u] = []
        self.graph[u].append(v)

    def dfs(self, start):
        visited = set()
        self._dfs_helper(start, visited)

    def _dfs_helper(self, node, visited):
        if node not in visited:
            print(node)
            visited.add(node)
            for neighbor in self.graph.get(node, []):
                self._dfs_helper(neighbor, visited)",Useful
This function counts the frequency of each word in a given text.,"def count_words(text):
    words = text.split()
    word_count = {}
    for word in words:
        word = word.lower()
        if word in word_count:
            word_count[word] += 1
        else:
            word_count[word] = 1
    return word_count",Useful
This function creates a debounced version of a function.,"function debounce(func, delay) {
    let timeout;
    return function(...args) {
        const context = this;
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(context, args), delay);
    };
}",Useful
This function calculates the factorial of a number recursively.,"fn factorial(n: u64) -> u64 {
    if n == 0 {
        1
    } else {
        n * factorial(n - 1)
    }
}",Useful
This function checks if a number is prime.,"def is_prime(num):
    if num < 2:
        return False
    for i in range(2, int(num**0.5) + 1):
        if num % i == 0:
            return False
    return True",Useful
This function merges two sorted arrays into one sorted array.,"function merge(arr1, arr2) {
    let merged = [];
    let i = 0, j = 0;
    while (i < arr1.length && j < arr2.length) {
        if (arr1[i] < arr2[j]) {
            merged.push(arr1[i++]);
        } else {
            merged.push(arr2[j++]);
        }
    }
    return merged.concat(arr1.slice(i)).concat(arr2.slice(j));
}",Useful
This struct represents a point in 2D space and includes a method to calculate the distance to another point.,"pub struct Point {
    x: f64,
    y: f64,
}

impl Point {
    pub fn new(x: f64, y: f64) -> Point {
        Point { x, y }
    }

    pub fn distance(&self, other: &Point) -> f64 {
        let dx = self.x - other.x;
        let dy = self.y - other.y;
        (dx * dx + dy * dy).sqrt()
    }
}",Useful
This class implements a stack data structure with basic operations.,"class Stack:
    def __init__(self):
        self.items = []

    def push(self, item):
        self.items.append(item)

    def pop(self):
        return self.items.pop() if not self.is_empty() else None

    def is_empty(self):
        return len(self.items) == 0",Useful
This function limits the rate at which a function can be executed.,"function throttle(func, limit) {
    let lastFunc;
    let lastRan;
    return function() {
        const context = this;
        const args = arguments;
        if (!lastRan) {
            func.apply(context, args);
            lastRan = Date.now();
        } else {
            clearTimeout(lastFunc);
            lastFunc = setTimeout(function() {
                if ((Date.now() - lastRan) >= limit) {
                    func.apply(context, args);
                    lastRan = Date.now();
                }
            }, limit - (Date.now() - lastRan));
        }
    };
}",Useful
This function calculates the area of a circle given its radius.,"def calculate_area_of_circle(radius):
    return 3.14159 * (radius ** 2)",Useful
This function finds the longest common prefix string among an array of strings.,"pub fn longest_common_prefix(strs: Vec<&str>) -> String {
    if strs.is_empty() { return String::new(); }
    let mut prefix = strs[0].to_string();
    for s in &strs[1..] {
        while !s.starts_with(&prefix) {
            prefix.pop();
        }
    }
    prefix
}",Useful
This class implements a queue data structure with basic operations.,"class Queue:
    def __init__(self):
        self.items = []

    def enqueue(self, item):
        self.items.insert(0, item)

    def dequeue(self):
        return self.items.pop() if not self.is_empty() else None

    def is_empty(self):
        return len(self.items) == 0",Useful
This function flattens a nested list into a single list.,"def flatten_list(nested_list):
    flat_list = []
    for sublist in nested_list:
        if isinstance(sublist, list):
            flat_list.extend(flatten_list(sublist))
        else:
            flat_list.append(sublist)
    return flat_list",Useful
"This function sorts an array using the merge sort algorithm, implemented in Rust.","fn merge_sort(arr: &mut [i32]) {
    let len = arr.len();
    if len < 2 {
        return;
    }
    let mid = len / 2;
    merge_sort(&mut arr[..mid]);
    merge_sort(&mut arr[mid..]);
    let mut merged = Vec::new();
    let (mut left, mut right) = (0, mid);
    while left < mid && right < len {
        if arr[left] < arr[right] {
            merged.push(arr[left]);
            left += 1;
        } else {
            merged.push(arr[right]);
            right += 1;
        }
    }
    while left < mid {
        merged.push(arr[left]);
        left += 1;
    }
    while right < len {
        merged.push(arr[right]);
        right += 1;
    }
    arr.copy_from_slice(&merged);
}",Useful
This function calculates the height of a binary tree.,"def binary_tree_height(node):
    if not node:
        return -1
    left_height = binary_tree_height(node.left)
    right_height = binary_tree_height(node.right)
    return max(left_height, right_height) + 1",Useful
This function computes the factorial of a number using recursion.,"function factorial(n) {
    if (n === 0) return 1;
    return n * factorial(n - 1);
}",Useful
This function checks if a string is a palindrome.,"pub fn is_palindrome(s: &str) -> bool {
    let s = s.chars().collect::<Vec<_>>();
    let len = s.len();
    for i in 0..len / 2 {
        if s[i] != s[len - 1 - i] {
            return false;
        }
    }
    true
}",Useful
This function reverses a given string.,"def reverse_string(s):
    return s[::-1]",Useful
This function computes the nth Fibonacci number using recursion.,"pub fn fibonacci(n: u64) -> u64 {
    if n <= 1 {
        return n;
    }
    fibonacci(n - 1) + fibonacci(n - 2)
}",Useful
This function groups words that are anagrams of each other.,"def group_anagrams(words):
    anagrams = {}
    for word in words:
        sorted_word = ''.join(sorted(word))
        anagrams.setdefault(sorted_word, []).append(word)
    return list(anagrams.values())",Useful
This function generates a random integer between min and max.,"function random_integer(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}",Useful
This function calculates the sum of squares of numbers from 1 to n.,"pub fn sum_of_squares(n: u64) -> u64 {
    (1..=n).map(|x| x * x).sum()
}",Useful
This function returns the prime factors of a given number.,"def prime_factors(n):
    i = 2
    factors = []
    while i * i <= n:
        if n % i:
            i += 1
        else:
            n //= i
            factors.append(i)
    if n > 1:
        factors.append(n)
    return factors",Useful
This function returns an array with unique elements from the input array.,"function unique_elements(arr) {
    return [...new Set(arr)];
}",Useful
This function counts the number of vowels in a string.,"pub fn count_vowels(s: &str) -> usize {
    s.chars().filter(|&c| ""aeiouAEIOU"".contains(c)).count()
}",Useful
This function finds the character with the maximum occurrence in a string.,"def get_max_occurrence(string):
    count = {}
    for char in string:
        count[char] = count.get(char, 0) + 1
    return max(count, key=count.get)",Useful
This function removes duplicate items from an array.,"function remove_duplicates(arr) {
    return arr.filter((item, index) => arr.indexOf(item) === index);
}",Useful
This function calculates the greatest common divisor of two numbers using recursion.,"pub fn gcd(a: u64, b: u64) -> u64 {
    if b == 0 {
        return a;
    }
    gcd(b, a % b)
}",Useful
This function finds the length of the longest substring without repeating characters.,"def longest_substring_without_repeating(s):
    start = max_length = 0
    used_chars = {}
    for index, char in enumerate(s):
        if char in used_chars and used_chars[char] >= start:
            start = used_chars[char] + 1
        used_chars[char] = index
        max_length = max(max_length, index - start + 1)
    return max_length",Useful
This function returns indices of the two numbers such that they add up to a specific target.,"pub fn two_sum(nums: Vec<i32>, target: i32) -> Vec<i32> {
    let mut map = HashMap::new();
    for (i, &num) in nums.iter().enumerate() {
        if let Some(&j) = map.get(&(target - num)) {
            return vec![j, i as i32];
        }
        map.insert(num, i);
    }
    vec![]
}",Useful
"This function implements the merge sort algorithm, which is a divide-and-conquer sorting technique that recursively splits the array into halves and merges them back in sorted order.",def merge_sort(arr): if len(arr) > 1: mid = len(arr) // 2 left_half = arr[:mid] right_half = arr[mid:] merge_sort(left_half) merge_sort(right_half) i = j = k = 0 while i < len(left_half) and j < len(right_half): if left_half[i] < right_half[j]: arr[k] = left_half[i] i += 1 else: arr[k] = right_half[j] j += 1 k += 1 while i < len(left_half): arr[k] = left_half[i] i += 1 k += 1 while j < len(right_half): arr[k] = right_half[j] j += 1 k += 1,Useful
This class does something with graphs.,"class Graph: def __init__(self): self.graph = {} def add_edge(self, v, w): if v not in self.graph: self.graph[v] = [] self.graph[v].append(w)",Not Useful
This is a sorting algorithm.,"const quickSort = (arr) => { if (arr.length <= 1) return arr; const pivot = arr[arr.length - 1]; const left = []; const right = []; for (let i = 0; i < arr.length - 1; i++) { if (arr[i] < pivot) left.push(arr[i]); else right.push(arr[i]); } return [...quickSort(left), pivot, ...quickSort(right)]; };",Not Useful
Calculates Fibonacci numbers.,fn fibonacci(n: u32) -> u32 { if n <= 1 { return n; } fibonacci(n - 1) + fibonacci(n - 2) },Not Useful
Returns the average.,def calculate_average(grades): total = sum(grades) count = len(grades) return total / count if count > 0 else 0,Not Useful
This class represents a binary tree and provides methods to insert values into the tree.,"class BinaryTree: def __init__(self): self.root = None def insert(self, value): if self.root is None: self.root = Node(value) else: self._insert_recursively(self.root, value) def _insert_recursively(self, node, value): if value < node.value: if node.left is None: node.left = Node(value) else: self._insert_recursively(node.left, value) else: if node.right is None: node.right = Node(value) else: self._insert_recursively(node.right, value)",Useful
This function is used for debouncing.,"function debounce(func, delay) { let timer; return function(...args) { const context = this; clearTimeout(timer); timer = setTimeout(() => func.apply(context, args), delay); }; }",Not Useful
This function implements merge sort generically for any type that implements the Ord trait.,"pub fn merge_sort<T: Ord>(array: &mut [T]) { let len = array.len(); if len < 2 { return; } let mid = len / 2; merge_sort(&mut array[..mid]); merge_sort(&mut array[mid..]); let mut temp = Vec::with_capacity(len); let (mut left, mut right) = (0, mid); while left < mid && right < len { if array[left] <= array[right] { temp.push(array[left]); left += 1; } else { temp.push(array[right]); right += 1; } } temp.extend_from_slice(&array[left..mid]); temp.extend_from_slice(&array[right..]); array.copy_from_slice(&temp); }",Useful
Solves the knapsack problem using dynamic programming.,"def knapsack(weights, values, capacity): n = len(values) K = [[0 for _ in range(capacity + 1)] for _ in range(n + 1)] for i in range(n + 1): for w in range(capacity + 1): if i == 0 or w == 0: K[i][w] = 0 elif weights[i - 1] <= w: K[i][w] = max(values[i - 1] + K[i - 1][w - weights[i - 1]], K[i - 1][w]) else: K[i][w] = K[i - 1][w] return K[n][capacity]",Useful
Checks if a string is a palindrome.,const isPalindrome = (str) => { const reversed = str.split('').reverse().join(''); return str === reversed; };,Useful
This class is a basic linked list implementation.,"class LinkedList: def __init__(self): self.head = None def append(self, data): new_node = Node(data) if not self.head: self.head = new_node return current = self.head while current.next: current = current.next current.next = new_node",Useful
Calculates the greatest common divisor of two numbers.,"fn gcd(a: u64, b: u64) -> u64 { if b == 0 { a } else { gcd(b, a % b) } }",Useful
Implements Dijkstra's algorithm to find the shortest path in a weighted graph.,"def dijkstra(graph, start): shortest_distance = {node: float('infinity') for node in graph} shortest_distance[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) for neighbor, weight in graph[current_node].items(): distance = current_distance + weight if distance < shortest_distance[neighbor]: shortest_distance[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return shortest_distance",Useful
This class is a stack implementation.,public class MyStack { private LinkedList<Integer> list = new LinkedList<>(); public void push(int value) { list.addFirst(value); } public int pop() { return list.removeFirst(); } public boolean isEmpty() { return list.isEmpty(); } },Useful
Flattens a nested array.,"function flatten(arr) { return arr.reduce((acc, val) => acc.concat(Array.isArray(val) ? flatten(val) : val), []); }",Useful
Generates all permutations of a list of numbers.,def permutations(nums): if len(nums) == 0: return [[]] res = [] for i in range(len(nums)): for p in permutations(nums[:i] + nums[i + 1:]): res.append([nums[i]] + p) return res,Useful
Performs a binary search on a sorted array.,"fn binary_search<T: Ord>(arr: &[T], target: T) -> Option<usize> { let mut left = 0; let mut right = arr.len(); while left < right { let mid = left + (right - left) / 2; if arr[mid] == target { return Some(mid); } else if arr[mid] < target { left = mid + 1; } else { right = mid; } } None }",Useful
This class implements a min-heap data structure.,"class MinHeap: def __init__(self): self.heap = [] def insert(self, key): self.heap.append(key) self._heapify_up(len(self.heap) - 1) def _heapify_up(self, index): parent_index = (index - 1) // 2 if index > 0 and self.heap[index] < self.heap[parent_index]: self.heap[index], self.heap[parent_index] = self.heap[parent_index], self.heap[index] self._heapify_up(parent_index)",Useful
Calculates the factorial of a number recursively.,function calculateFactorial(n) { if (n === 0 || n === 1) return 1; return n * calculateFactorial(n - 1); },Useful
This function checks if two strings are anagrams.,"def is_anagram(str1, str2): return sorted(str1) == sorted(str2)",Useful
This class implements a basic queue.,"class Queue: def __init__(self): self.items = [] def enqueue(self, item): self.items.append(item) def dequeue(self): return self.items.pop(0)",Useful
Generates a list of prime numbers up to n using the Sieve of Eratosthenes.,"fn prime_sieve(n: usize) -> Vec<usize> { let mut primes = vec![true; n + 1]; primes[0] = false; primes[1] = false; for p in 2..=((n as f64).sqrt() as usize) { if primes[p] { for multiple in (p*p..=n).step_by(p) { primes[multiple] = false; } } } primes.into_iter().enumerate().filter_map(|(i, &is_prime)| if is_prime { Some(i) } else { None }).collect() }",Useful
Implements the breadth-first search algorithm for traversing a graph.,"def bfs(graph, start): visited = set() queue = [start] while queue: vertex = queue.pop(0) if vertex not in visited: visited.add(vertex) neighbors = graph[vertex] for neighbor in neighbors: queue.append(neighbor) return visited",Useful
Merges two sorted arrays into one sorted array.,"const mergeSortedArrays = (arr1, arr2) => { let merged = []; let i = 0, j = 0; while (i < arr1.length && j < arr2.length) { if (arr1[i] < arr2[j]) { merged.push(arr1[i++]); } else { merged.push(arr2[j++]); } } return merged.concat(arr1.slice(i)).concat(arr2.slice(j)); };",Useful
This class implements a Trie data structure for efficient storage and retrieval of strings.,"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True",Useful
Rotates an array to the right by k steps.,"function rotateArray(arr, k) { const n = arr.length; k = k % n; const rotated = arr.slice(n - k).concat(arr.slice(0, n - k)); return rotated; }",Useful
Computes the length of the longest common subsequence between two strings.,"def longest_common_subsequence(str1, str2): m, n = len(str1), len(str2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]",Useful
Calculates the factorial using recursion.,fn factorial(n: u64) -> u64 { if n <= 1 { 1 } else { n * factorial(n - 1) } },Useful
This class implements a segment tree for range query problems.,"class SegmentTree: def __init__(self, data): self.n = len(data) self.tree = [0] * (2 * self.n) for i in range(self.n): self.tree[self.n + i] = data[i] for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[i << 1] + self.tree[i << 1 | 1]",Useful
Shuffles an array randomly.,"function shuffleArray(arr) { for (let i = arr.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [arr[i], arr[j]] = [arr[j], arr[i]]; } return arr; }",Useful
Counts the number of inversions in an array using merge sort.,"def count_inversions(arr): def merge_count_split_inv(arr, temp_arr, left, mid, right): i = left    j = mid    k = left    inv_count = 0 while i <= mid - 1 and j <= right: if arr[i] <= arr[j]: temp_arr[k] = arr[i] i += 1 else: temp_arr[k] = arr[j] inv_count += (mid - i) j += 1 k += 1 while i <= mid - 1: temp_arr[k] = arr[i] i += 1 k += 1 while j <= right: temp_arr[k] = arr[j] j += 1 k += 1 for i in range(left, right + 1): arr[i] = temp_arr[i] return inv_count",Useful
Sorts an array using the bubble sort algorithm.,"pub fn bubble_sort(arr: &mut [i32]) { let n = arr.len(); for i in 0..n { for j in 0..n - 1 - i { if arr[j] > arr[j + 1] { arr.swap(j, j + 1); } } } }",Useful
Generates the first n Fibonacci numbers.,"function getFibonacci(n) { let a = 0, b = 1; const result = []; for (let i = 0; i < n; i++) { result.push(a); [a, b] = [b, a + b]; } return result; }",Useful
Finds the top k most frequent elements in a list.,"def top_k_frequent(nums, k): count = collections.Counter(nums) return [item for item, freq in count.most_common(k)]",Useful
This class implements a Least Recently Used (LRU) cache.,"class LRUCache: def __init__(self, capacity: int): self.cache = {} self.capacity = capacity self.order = [] def get(self, key: int) -> int: if key in self.cache: self.order.remove(key) self.order.append(key) return self.cache[key] return -1 def put(self, key: int, value: int) -> None: if key in self.cache: self.order.remove(key) else: if len(self.order) >= self.capacity: oldest = self.order.pop(0) del self.cache[oldest] self.cache[key] = value self.order.append(key)",Useful
"This function implements the merge sort algorithm, which is a recursive sorting technique that divides the input array into halves.",def merge_sort(arr): if len(arr) > 1: mid = len(arr) // 2 left_half = arr[:mid] right_half = arr[mid:] merge_sort(left_half) merge_sort(right_half) i = j = k = 0 while i < len(left_half) and j < len(right_half): if left_half[i] < right_half[j]: arr[k] = left_half[i] i += 1 else: arr[k] = right_half[j] j += 1 k += 1 while i < len(left_half): arr[k] = left_half[i] i += 1 k += 1 while j < len(right_half): arr[k] = right_half[j] j += 1 k += 1,Useful
This function calculates a number in the Fibonacci sequence.,function fibonacci(n) { if (n <= 1) return n; return fibonacci(n - 1) + fibonacci(n - 2); },Not Useful
This class represents a node in a binary tree.,"class Node: def __init__(self, key): self.left = None self.right = None self.val = key def insert(root, key): if root is None: return Node(key) else: if root.val < key: root.right = insert(root.right, key) else: root.left = insert(root.left, key) return root",Not Useful
This struct defines a point in a 2D space and includes a method to calculate the distance to another point.,"pub struct Point { x: f64, y: f64 } impl Point { pub fn distance(&self, other: &Point) -> f64 { ((self.x - other.x).powi(2) + (self.y - other.y).powi(2)).sqrt() } }",Useful
This class is designed to represent a graph using adjacency lists.,"class Graph: def __init__(self): self.graph = {} def add_edge(self, u, v): if u in self.graph: self.graph[u].append(v) else: self.graph[u] = [v]",Useful
"This function sorts an array using the quicksort algorithm, which is a divide-and-conquer approach.",def quicksort(arr): if len(arr) <= 1: return arr pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quicksort(left) + middle + quicksort(right),Useful
This function calculates the factorial of a number using Rust's range and product methods.,fn factorial(n: u64) -> u64 { (1..=n).product() },Useful
This function implements the binary search algorithm to find the index of a target value in a sorted array.,"def binary_search(arr, target): low = 0 high = len(arr) - 1 while low <= high: mid = (low + high) // 2 if arr[mid] < target: low = mid + 1 elif arr[mid] > target: high = mid - 1 else: return mid return -1",Useful
This function checks if a given string is a palindrome.,function isPalindrome(str) { return str === str.split('').reverse().join(''); },Not Useful
This function retrieves data from a given URL and returns it as a JSON object.,async function fetchData(url) { const response = await fetch(url); const data = await response.json(); return data; },Useful
This class implements a basic stack data structure with push and pop operations.,"class Stack: def __init__(self): self.items = [] def push(self, item): self.items.append(item) def pop(self): return self.items.pop() if not self.is_empty() else 'Stack is empty' def is_empty(self): return len(self.items) == 0",Useful
This function counts the number of vowels in a given string.,def count_vowels(s): return sum(1 for char in s if char.lower() in 'aeiou'),Useful
This struct represents a rectangle and provides a method to calculate its area.,"struct Rectangle { width: f64, height: f64 } impl Rectangle { pub fn area(&self) -> f64 { self.width * self.height } }",Useful
This function implements Dijkstra's algorithm for finding the shortest paths in a weighted graph.,"def dijkstra(graph, start): shortest_path = {vertex: float('infinity') for vertex in graph} shortest_path[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_vertex = heapq.heappop(priority_queue) for neighbor, weight in graph[current_vertex].items(): distance = current_distance + weight if distance < shortest_path[neighbor]: shortest_path[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return shortest_path",Useful
This function merges two arrays and removes duplicates.,"function mergeArrays(arr1, arr2) { return [...new Set([...arr1, ...arr2])]; }",Useful
This function calculates the coefficients of a simple linear regression model.,"def linear_regression(x, y): n = len(x) m_x, m_y = sum(x) / n, sum(y) / n SS_xy = sum(y[i] * x[i] for i in range(n)) - n * m_y * m_x SS_xx = sum(x[i] * x[i] for i in range(n)) - n * m_x * m_x b_1 = SS_xy / SS_xx b_0 = m_y - b_1 * m_x return b_0, b_1",Useful
This class implements a binary tree with an insert method.,"class BinaryTree: def __init__(self, root): self.root = root self.left = None self.right = None def insert(self, value): if self.root: if value < self.root: if self.left is None: self.left = BinaryTree(value) else: self.left.insert(value) else: if self.right is None: self.right = BinaryTree(value) else: self.right.insert(value)",Useful
This function checks if a string has all unique characters using a HashSet.,fn unique_characters(s: &str) -> bool { let mut chars = std::collections::HashSet::new(); for c in s.chars() { if !chars.insert(c) { return false; } } true },Useful
This function solves the 0/1 knapsack problem using dynamic programming.,"def knapsack(weights, values, capacity): n = len(values) dp = [[0 for _ in range(capacity + 1)] for _ in range(n + 1)] for i in range(n + 1): for w in range(capacity + 1): if i == 0 or w == 0: dp[i][w] = 0 elif weights[i-1] <= w: dp[i][w] = max(values[i-1] + dp[i-1][w - weights[i-1]], dp[i-1][w]) else: dp[i][w] = dp[i-1][w] return dp[n][capacity]",Useful
This function creates a debounced version of a function that delays its execution.,"function debounce(func, wait) { let timeout; return function executedFunction(...args) { const later = () => { timeout = null; func(...args); }; clearTimeout(timeout); timeout = setTimeout(later, wait); }; };",Useful
This function performs a breadth-first search on a graph starting from a specified vertex.,"def bfs(graph, start): visited = set() queue = [start] while queue: vertex = queue.pop(0) if vertex not in visited: visited.add(vertex) queue.extend(set(graph[vertex]) - visited) return visited",Useful
This class implements a basic queue data structure with enqueue and dequeue operations.,"class Queue: def __init__(self): self.items = [] def enqueue(self, item): self.items.insert(0, item) def dequeue(self): return self.items.pop() if not self.is_empty() else 'Queue is empty' def is_empty(self): return len(self.items) == 0",Useful
This function rotates a square matrix 90 degrees clockwise.,"def rotate_matrix(matrix): n = len(matrix) for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] for i in range(n): matrix[i].reverse() return matrix",Useful
This function calculates the greatest common divisor using recursion.,"fn gcd(a: u64, b: u64) -> u64 { if b == 0 { a } else { gcd(b, a % b) } }",Useful
This class implements a simple counter with increment and get methods.,class Counter: def __init__(self): self.count = 0 def increment(self): self.count += 1 def get_count(self): return self.count,Useful
This function flattens a nested array into a single array.,"function flattenArray(arr) { return arr.reduce((flat, toFlatten) => flat.concat(Array.isArray(toFlatten) ? flattenArray(toFlatten) : toFlatten), []); }",Useful
This function generates all possible permutations of a list of numbers.,def permute(nums): if len(nums) == 0: return [[]] return [[nums[i]] + p for i in range(len(nums)) for p in permute(nums[:i] + nums[i+1:])],Useful
This class implements a min-heap data structure with insert functionality.,"class MinHeap: def __init__(self): self.heap = [] def parent(self, i): return (i - 1) // 2 def left(self, i): return 2 * i + 1 def right(self, i): return 2 * i + 2 def insert(self, key): self.heap.append(key) i = len(self.heap) - 1 while i != 0 and self.heap[self.parent(i)] > self.heap[i]: self.heap[self.parent(i)], self.heap[i] = self.heap[i], self.heap[self.parent(i)] i = self.parent(i)",Useful
This function checks if two strings are anagrams of each other.,"def is_anagram(str1, str2): return sorted(str1) == sorted(str2)",Not Useful
This function performs binary search on a sorted array.,"fn binary_search(arr: &[i32], target: i32) -> Option<usize> { let mut low = 0; let mut high = arr.len() as isize - 1; while low <= high { let mid = (low + high) / 2; if arr[mid as usize] == target { return Some(mid as usize); } else if arr[mid as usize] < target { low = mid + 1; } else { high = mid - 1; } } None }",Useful
This function sorts an array using the selection sort algorithm.,"def selection_sort(arr): for i in range(len(arr)): min_idx = i for j in range(i+1, len(arr)): if arr[j] < arr[min_idx]: min_idx = j arr[i], arr[min_idx] = arr[min_idx], arr[i]",Not Useful
This function creates a delay for a specified number of milliseconds.,"async function delay(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }",Useful
This function finds the length of the longest common subsequence between two strings using dynamic programming.,"def lcs(X, Y): m = len(X) n = len(Y) L = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0 or j == 0: L[i][j] = 0 elif X[i - 1] == Y[j - 1]: L[i][j] = L[i - 1][j - 1] + 1 else: L[i][j] = max(L[i - 1][j], L[i][j - 1]) return L[m][n]",Useful
This is a class for an AVL Tree.,"class AVLTree: def __init__(self): self.root = None def insert(self, key): # code to insert and balance the AVL tree",Not Useful
This function limits the rate at which a function can fire.,"function throttle(func, limit) { let lastFunc; let lastRan; return function() { const context = this; const args = arguments; if (!lastRan || (Date.now() - lastRan) >= limit) { func.apply(context, args); lastRan = Date.now(); } } };",Useful
"Applies a discount to a list of prices, ensuring that only positive prices are processed.","def apply_discount(prices, discount): return [price - (price * discount) for price in prices if price > 0]",Useful
Combines two dictionaries into one.,"def merge_dicts(dict1, dict2): return {**dict1, **dict2}",Not Useful
Limits the rate at which a function can fire.,"function debounce(func, wait) { let timeout; return function executedFunction(...args) { const later = () => { timeout = null; if (args.length) func(...args); }; clearTimeout(timeout); timeout = setTimeout(later, wait); }; }; }",Useful
Calculates the midpoint between two points.,"struct Point { int x; int y; }; Point midpoint(Point p1, Point p2) { return { (p1.x + p2.x) / 2, (p1.y + p2.y) / 2 }; }",Useful
Fetches data from a URL and returns it as JSON.,const fetchData = async (url) => { const response = await fetch(url); return await response.json(); };,Not Useful
Flattens a nested list into a single list.,def flatten(nested_list): return [item for sublist in nested_list for item in sublist],Useful
Reverses a linked list.,class Node { public: int data; Node* next; }; Node* reverse(Node* head) { Node* prev = nullptr; while (head) { Node* next = head->next; head->next = prev; prev = head; head = next; } return prev; },Not Useful
Ensures a function is called at most once in a specified time interval.,"const throttle = (func, limit) => { let lastFunc; let lastRan; return function() { const context = this; const args = arguments; if (!lastRan) { func.apply(context, args); lastRan = Date.now(); } else { clearTimeout(lastFunc); lastFunc = setTimeout(() => { if ((Date.now() - lastRan) >= limit) { func.apply(context, args); lastRan = Date.now(); } }, limit - (Date.now() - lastRan)); } }; };",Useful
Checks if a string is a palindrome.,def is_palindrome(s): return s == s[::-1],Not Useful
Finds all prime factors of a given number.,"def prime_factors(n): factors = [] for i in range(2, n + 1): while n % i == 0: factors.append(i) n //= i return factors",Useful
Calculates the nth Fibonacci number using recursion.,"fn fibonacci(n: u32) -> u32 { match n { 0 => 0, 1 => 1, _ => fibonacci(n - 1) + fibonacci(n - 2) } }",Not Useful
Generates a random UUID.,"const generateUUID = () => { return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => { const r = Math.random() * 16 | 0; const v = c === 'x' ? r : (r & 0x3 | 0x8); return v.toString(16); }); };",Useful
This function sorts an array using the merge sort algorithm.,def merge_sort(arr): if len(arr) > 1: mid = len(arr) // 2 left_half = arr[:mid] right_half = arr[mid:] merge_sort(left_half) merge_sort(right_half) i = j = k = 0 while i < len(left_half) and j < len(right_half): if left_half[i] < right_half[j]: arr[k] = left_half[i] i += 1 else: arr[k] = right_half[j] j += 1 k += 1 while i < len(left_half): arr[k] = left_half[i] i += 1 k += 1 while j < len(right_half): arr[k] = right_half[j] j += 1 k += 1 return arr,Not Useful
Implements a circular queue with enqueue and dequeue operations.,"class CircularQueue { private: int front, rear, size; int* queue; public: CircularQueue(int size) { this->size = size; front = rear = 0; queue = new int[size]; } void enqueue(int data) { queue[rear] = data; rear = (rear + 1) % size; } int dequeue() { int data = queue[front]; front = (front + 1) % size; return data; } };",Useful
Counts how many times an element appears in an array.,"def count_occurrences(arr, x): return arr.count(x)",Not Useful
"Creates a counter object with increment, decrement, and getCount methods.","const createCounter = () => { let count = 0; return { increment: () => { count++; return count; }, decrement: () => { count--; return count; }, getCount: () => count }; };",Useful
Checks if two strings are anagrams of each other.,"fn is_anagram(s1: &str, s2: &str) -> bool { let mut s1_chars: Vec<_> = s1.chars().collect(); let mut s2_chars: Vec<_> = s2.chars().collect(); s1_chars.sort(); s2_chars.sort(); s1_chars == s2_chars }",Useful
Calculates the area of a circle given its radius.,def calculate_area(radius): return 3.14 * radius ** 2,Not Useful
Implements a stack data structure with push and pop functionality.,class Stack { private: std::vector<int> stack; public: void push(int value) { stack.push_back(value); } int pop() { int value = stack.back(); stack.pop_back(); return value; } bool isEmpty() { return stack.empty(); } };,Useful
Filters out falsy values from an array.,function filterFalsy(arr) { return arr.filter(Boolean); },Not Useful
Finds the length of the longest substring without repeating characters.,"def length_of_longest_substring(s): chars = set() left = result = 0 for right in range(len(s)): if s[right] in chars: while s[left] != s[right]: chars.remove(s[left]); left += 1 chars.add(s[right]) result = max(result, right - left + 1) return result",Useful
Represents a graph using an adjacency list.,"class Graph { private: std::unordered_map<int, std::vector<int>> adjList; public: void addEdge(int v, int w) { adjList[v].push_back(w); } std::vector<int> getNeighbors(int v) { return adjList[v]; } };",Useful
Rotates a matrix 90 degrees clockwise.,def rotate_matrix(matrix): return [list(row) for row in zip(*matrix[::-1])],Not Useful
Sorts an array using the quicksort algorithm.,"const quickSort = (arr) => { if (arr.length <= 1) return arr; const pivot = arr[arr.length - 1]; const left = arr.filter(x => x < pivot); const right = arr.filter(x => x > pivot); return [...quickSort(left), pivot, ...quickSort(right)]; };",Not Useful
Calculates the greatest common divisor of two numbers using recursion.,"fn gcd(a: i32, b: i32) -> i32 { if b == 0 { a } else { gcd(b, a % b) } }",Useful
Performs a binary search on a sorted array.,"def binary_search(arr, target): left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: return mid elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return -1",Not Useful
Limits the rate at which a function can be called.,"const debounce = (fn, delay) => { let timer; return function(...args) { const context = this; clearTimeout(timer); timer = setTimeout(() => fn.apply(context, args), delay); }; };",Useful
Implements a priority queue using a heap.,"class PriorityQueue { private: std::vector<int> heap; public: void push(int value) { heap.push_back(value); std::push_heap(heap.begin(), heap.end()); } int pop() { std::pop_heap(heap.begin(), heap.end()); int value = heap.back(); heap.pop_back(); return value; } };",Useful
Finds the missing number in a given array of integers.,def find_missing_number(arr): n = len(arr) + 1 total_sum = n * (n + 1) // 2 return total_sum - sum(arr),Useful
Merges two arrays and removes duplicates.,"const mergeArrays = (arr1, arr2) => { return [...new Set([...arr1, ...arr2])]; };",Useful
Solves the Tower of Hanoi problem using recursion.,"fn tower_of_hanoi(n: usize, source: &str, target: &str, auxiliary: &str) { if n == 1 { println!(""Move disk 1 from {} to {}"", source, target); return; } tower_of_hanoi(n - 1, source, auxiliary, target); println!(""Move disk {} from {} to {}"", n, source, target); tower_of_hanoi(n - 1, auxiliary, target, source); }",Useful
Finds the longest common prefix string among an array of strings.,def longest_common_prefix(strs): if not strs: return '' prefix = strs[0] for s in strs[1:]: while s[:len(prefix)] != prefix and prefix: prefix = prefix[:-1] return prefix,Useful
Implements an AVL tree with insertion logic.,"class AVLTree { private: struct Node { int key; Node* left; Node* right; int height; }; Node* insert(Node* node, int key) { // insert logic } };",Not Useful
Groups anagrams together from a list of strings.,def group_anagrams(strs): from collections import defaultdict anagrams = defaultdict(list) for s in strs: anagrams[tuple(sorted(s))].append(s) return list(anagrams.values()),Useful
Checks if a string is a palindrome.,const isPalindrome = (s) => { return s === s.split('').reverse().join(''); };,Not Useful
"Merges two dictionaries, summing values for common keys.","def merge_dicts(dict1, dict2): return {k: dict1.get(k, 0) + dict2.get(k, 0) for k in set(dict1) | set(dict2)}",Useful
Limits the rate at which a function can fire.,"function debounce(func, delay) { let timeout; return function(...args) { clearTimeout(timeout); timeout = setTimeout(() => func.apply(this, args), delay); }}",Useful
Defines a simple Graph class and initializes an empty node collection.,class Graph { constructor() { this.nodes = {}; } addNode(node) { this.nodes[node] = []; } },Useful
Calculates the factorial of a non-negative integer using recursion.,fn factorial(n: u32) -> u32 { if n == 0 { 1 } else { n * factorial(n - 1) } },Useful
Returns a list of unique elements from the input list.,def unique_elements(lst): return list(set(lst)),Useful
Fetches data from a URL and returns the parsed JSON response.,const fetchData = async (url) => { const response = await fetch(url); return response.json(); },Useful
A simple stack implementation using templates in C++.,template <typename T> class Stack { private: std::vector<T> elements; public: void push(const T& element) { elements.push_back(element); } },Useful
Flattens a list of lists into a single list.,def flatten(lst): return [item for sublist in lst for item in sublist],Useful
Limits the number of times a function can be called in a given time frame.,"function throttle(func, limit) { let lastFunc; let lastRan; return function() { const context = this; const args = arguments; if (!lastRan) { func.apply(context, args); lastRan = Date.now(); } else { clearTimeout(lastFunc); lastFunc = setTimeout(function() { if ((Date.now() - lastRan) >= limit) { func.apply(context, args); lastRan = Date.now(); } }, limit - (Date.now() - lastRan)); } } }",Useful
Defines a Node struct for a linked list and provides a method to add a new node.,"type Node struct { value int next *Node } func (n *Node) add(value int) { newNode := &Node{value: value, next: n.next} n.next = newNode }",Useful
Performs a binary search on a sorted array to find the target value.,"def binary_search(arr, target): low, high = 0, len(arr) - 1 while low <= high: mid = (low + high) // 2 if arr[mid] == target: return mid elif arr[mid] < target: low = mid + 1 else: high = mid - 1 return -1",Not Useful
Checks if a string is a palindrome by comparing it with its reverse.,function isPalindrome(str) { return str === str.split('').reverse().join(''); },Useful
Implements a queue with enqueue and dequeue operations.,class Queue { constructor() { this.items = []; } enqueue(element) { this.items.push(element); } dequeue() { return this.items.shift(); } },Useful
Sorts an array using the merge sort algorithm.,fn merge_sort(arr: &mut [i32]) { if arr.len() <= 1 { return; } let mid = arr.len() / 2; let mut left = arr[0..mid].to_vec(); let mut right = arr[mid..].to_vec(); merge_sort(&mut left); merge_sort(&mut right); let mut i = 0; let mut j = 0; let mut k = 0; while i < left.len() && j < right.len() { if left[i] <= right[j] { arr[k] = left[i]; i += 1; } else { arr[k] = right[j]; j += 1; } k += 1; } while i < left.len() { arr[k] = left[i]; i += 1; k += 1; } while j < right.len() { arr[k] = right[j]; j += 1; k += 1; } },Not Useful
Caches results of function calls to optimize performance.,def cache(func): cached_results = {} def wrapper(*args): if args in cached_results: return cached_results[args] result = func(*args) cached_results[args] = result return result return wrapper,Useful
Defines a binary tree and includes methods for inserting new values.,class BinaryTree { constructor(value) { this.value = value; this.left = null; this.right = null; } insert(value) { if (value < this.value) { if (this.left) { this.left.insert(value); } else { this.left = new BinaryTree(value); } } else { if (this.right) { this.right.insert(value); } else { this.right = new BinaryTree(value); } } } },Useful
Defines a Person struct and a method to greet.,"type Person struct { Name string Age int } func (p *Person) Greet() string { return ""Hello, my name is "" + p.Name }",Useful
Reverses the input string using Python slicing.,def reverse_string(s): return s[::-1],Useful
Determines if a number is prime by checking divisibility.,const isPrime = (num) => { if (num <= 1) return false; for (let i = 2; i <= Math.sqrt(num); i++) { if (num % i === 0) return false; } return true; },Useful
Calculates the nth Fibonacci number using recursion.,fn fibonacci(n: u32) -> u32 { if n <= 1 { return n; } fibonacci(n - 1) + fibonacci(n - 2) },Not Useful
Finds the maximum sum of a contiguous subarray using Kadane's algorithm.,"def find_max_subarray(arr): max_sum = current_sum = arr[0] for num in arr[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum",Useful
Implements a min-heap data structure with an insert method.,"class MinHeap { constructor() { this.heap = []; } insert(num) { this.heap.push(num); this.bubbleUp(); } bubbleUp() { let index = this.heap.length - 1; while (index > 0) { let parentIndex = Math.floor((index - 1) / 2); if (this.heap[parentIndex] <= this.heap[index]) break; [this.heap[parentIndex], this.heap[index]] = [this.heap[index], this.heap[parentIndex]]; index = parentIndex; } } }",Useful
Calculates the greatest common divisor using the Euclidean algorithm.,"fn gcd(a: u32, b: u32) -> u32 { if b == 0 { a } else { gcd(b, a % b) } }",Useful
Calculates the product of all numbers in a list.,def product_of_list(lst): product = 1 for num in lst: product *= num return product,Useful
Recursively calculates the factorial of a number.,const factorial = (n) => { return n <= 1 ? 1 : n * factorial(n - 1); },Not Useful
Defines a base Shape class that requires an area method to be implemented.,class Shape { constructor(color) { this.color = color; } area() { throw 'Not implemented'; } },Useful
Sorts an array using the quick sort algorithm.,fn quick_sort(arr: &mut [i32]) { if arr.len() <= 1 { return; } let pivot = arr[arr.len() / 2]; let left: Vec<i32> = arr.iter().filter(|&&x| x < pivot).cloned().collect(); let right: Vec<i32> = arr.iter().filter(|&&x| x > pivot).cloned().collect(); quick_sort(&mut left); quick_sort(&mut right); arr.clear(); arr.extend(left); arr.push(pivot); arr.extend(right); },Not Useful
Counts the occurrences of each element in a list and returns a dictionary.,def count_occurrences(lst): from collections import Counter return dict(Counter(lst)),Useful
Finds the maximum value in an array.,function findMax(arr) { let max = arr[0]; for (let num of arr) { if (num > max) { max = num; } } return max; },Useful
Calculates the depth of a binary tree recursively.,"fn binary_tree_depth(node: &Option<Box<Node>>) -> usize { match node { Some(n) => 1 + std::cmp::max(binary_tree_depth(&n.left), binary_tree_depth(&n.right)), None => 0 } }",Not Useful
Splits a list into chunks of specified size.,"def chunk_list(lst, n): return [lst[i:i + n] for i in range(0, len(lst), n)]",Useful
Defines a Person class with a method to greet.,"class Person { constructor(name, age) { this.name = name; this.age = age; } greet() { return `Hello, my name is ${this.name}`; } }",Useful
Merges two sorted vectors into a single sorted vector.,"fn merge(left: Vec<i32>, right: Vec<i32>) -> Vec<i32> { let mut result = Vec::new(); let (mut i, mut j) = (0, 0); while i < left.len() && j < right.len() { if left[i] <= right[j] { result.push(left[i]); i += 1; } else { result.push(right[j]); j += 1; } } result.extend_from_slice(&left[i..]); result.extend_from_slice(&right[j..]); result",Useful
Counts down to zero using recursion.,function countDown(num) { if (num <= 0) { console.log('Done!'); return; } console.log(num); countDown(num - 1); },Not Useful
Checks if two strings are anagrams of each other.,"def is_anagram(str1, str2): return sorted(str1) == sorted(str2)",Useful
Transforms a function operating on strings/words to one that operates on numbers/indices,"def conjugate(self, f): return lambda i: self.word_index[f(self.index_word[i])]",Useful
"Splits the dataset into test, validation, and training sets based on repository IDs",test = empty | df.repo_id.map(test_repos.__contains__) valid = ~empty & df.repo_id.map(valid_repos.__contains__) train = ~valid & ~test,Useful
This function parses a custom format string into an iterator of CustomData structs,"fn parse_custom_format<'a>(input: &'a str) -> impl Iterator<Item = Result<CustomData, ParseError>> + 'a { input.lines().map(|line| { let parts: Vec<&str> = line.split(',').collect(); if parts.len() != 3 { return Err(ParseError::InvalidFormat); } Ok(CustomData { id: parts[0].parse()?, name: parts[1].to_string(), value: parts[2].parse()?, }) }) }",Useful
Creates a memoized version of a function to cache results,"const memoize = (fn) => { const cache = new Map(); return (...args) => { const key = JSON.stringify(args); if (cache.has(key)) return cache.get(key); const result = fn.apply(this, args); cache.set(key, result); return result; }; };",Useful
Implements a thread-safe queue using mutex and condition variable,"template<typename T> class ThreadSafeQueue { private: std::queue<T> queue; mutable std::mutex mutex; std::condition_variable cond; public: void push(T value) { std::lock_guard<std::mutex> lock(mutex); queue.push(std::move(value)); cond.notify_one(); } T pop() { std::unique_lock<std::mutex> lock(mutex); cond.wait(lock, [this] { return !queue.empty(); }); T value = std::move(queue.front()); queue.pop(); return value; } };",Useful
Decorator for priming coroutines automatically,"def coroutine_decorator(func): @wraps(func) def primer(*args, **kwargs): gen = func(*args, **kwargs) next(gen) return gen return primer",Useful
This function does something with promises,"async function retryWithBackoff(fn, maxRetries = 5, baseDelay = 100) { for (let i = 0; i < maxRetries; i++) { try { return await fn(); } catch (error) { if (i === maxRetries - 1) throw error; await new Promise(resolve => setTimeout(resolve, baseDelay * Math.pow(2, i))); } } }",Not Useful
Parses a log entry string into a structured LogEntry object using regex,"fn parse_log_entry(entry: &str) -> Result<LogEntry, ParseError> { let re = Regex::new(r""^(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}) \[(\w+)\] (.+)$"").unwrap(); let caps = re.captures(entry).ok_or(ParseError::InvalidFormat)?; Ok(LogEntry { timestamp: NaiveDateTime::parse_from_str(&caps[1], ""%Y-%m-%d %H:%M:%S"")?, level: caps[2].parse()?, message: caps[3].to_string(), }) }",Useful
Implements a Least Recently Used (LRU) cache with get and put operations,"class LRUCache<K, V> { private capacity: number; private cache: Map<K, V>; private keys: K[]; constructor(capacity: number) { this.capacity = capacity; this.cache = new Map<K, V>(); this.keys = []; } get(key: K): V | undefined { if (!this.cache.has(key)) return undefined; const value = this.cache.get(key); this.keys = this.keys.filter(k => k !== key); this.keys.unshift(key); return value; } put(key: K, value: V): void { if (this.cache.has(key)) { this.keys = this.keys.filter(k => k !== key); } else if (this.keys.length >= this.capacity) { const oldKey = this.keys.pop(); this.cache.delete(oldKey!); } this.cache.set(key, value); this.keys.unshift(key); } }",Useful
This function reduces an iterable using a custom function,"def custom_reduce(function, iterable, initializer=None): it = iter(iterable) if initializer is None: try: initializer = next(it) except StopIteration: raise TypeError('reduce() of empty sequence with no initial value') accum_value = initializer for x in it: accum_value = function(accum_value, x) return accum_value",Useful
Implements a thread-safe shared pointer with reference counting,"template <typename T> class SharedPtr { private: T* ptr; std::atomic<int>* refCount; void release() { if (ptr && --(*refCount) == 0) { delete ptr; delete refCount; } } public: explicit SharedPtr(T* p = nullptr) : ptr(p), refCount(new std::atomic<int>(1)) {} SharedPtr(const SharedPtr& other) : ptr(other.ptr), refCount(other.refCount) { ++(*refCount); } SharedPtr& operator=(const SharedPtr& other) { if (this != &other) { release(); ptr = other.ptr; refCount = other.refCount; ++(*refCount); } return *this; } ~SharedPtr() { release(); } T& operator*() const { return *ptr; } T* operator->() const { return ptr; } T* get() const { return ptr; } int use_count() const { return refCount->load(); } };",Useful
Fetches data from a URL with a timeout,"async function fetchWithTimeout(url, options = {}, timeout = 5000) { const controller = new AbortController(); const id = setTimeout(() => controller.abort(), timeout); const response = await fetch(url, { ...options, signal: controller.signal }); clearTimeout(id); return response; }",Useful
Implements a custom groupby function similar to itertools.groupby,"def custom_groupby(iterable, key=None): if key is None: key = lambda x: x class GroupByIterator: def __init__(self, iterable, key): self.it = iter(sorted(iterable, key=key)) self.tgtkey = self.currkey = self.currvalue = object() self.key = key def __iter__(self): return self def __next__(self): self.id = object() while self.currkey == self.tgtkey: self.currvalue = next(self.it) self.currkey = self.key(self.currvalue) self.tgtkey = self.currkey return (self.currkey, self._grouper(self.tgtkey, self.id)) def _grouper(self, tgtkey, id): while self.id is id and self.currkey == tgtkey: yield self.currvalue try: self.currvalue = next(self.it) except StopIteration: return self.currkey = self.key(self.currvalue) return GroupByIterator(iterable, key)",Useful
Implements a Trie data structure for efficient prefix-based string operations,"pub struct TrieNode { children: [Option<Box<TrieNode>>; 26], is_end: bool, } impl TrieNode { fn new() -> Self { TrieNode { children: Default::default(), is_end: false, } } } pub struct Trie { root: TrieNode, } impl Trie { pub fn new() -> Self { Trie { root: TrieNode::new() } } pub fn insert(&mut self, word: String) { let mut node = &mut self.root; for ch in word.chars() { let idx = (ch as u8 - b'a') as usize; node = node.children[idx].get_or_insert_with(|| Box::new(TrieNode::new())); } node.is_end = true; } pub fn search(&self, word: String) -> bool { let mut node = &self.root; for ch in word.chars() { let idx = (ch as u8 - b'a') as usize; match &node.children[idx] { Some(next) => node = next, None => return false, } } node.is_end } pub fn starts_with(&self, prefix: String) -> bool { let mut node = &self.root; for ch in prefix.chars() { let idx = (ch as u8 - b'a') as usize; match &node.children[idx] { Some(next) => node = next, None => return false, } } true }",Useful
Implements a circular buffer with fixed capacity and efficient push/pop operations,class CircularBuffer<T> { private buffer: T[]; private head: number = 0; private tail: number = 0; private size: number = 0; constructor(private capacity: number) { this.buffer = new Array(capacity); } push(item: T): void { if (this.size === this.capacity) { this.head = (this.head + 1) % this.capacity; } else { this.size++; } this.buffer[this.tail] = item; this.tail = (this.tail + 1) % this.capacity; } pop(): T | undefined { if (this.size === 0) return undefined; const item = this.buffer[this.head]; this.head = (this.head + 1) % this.capacity; this.size--; return item; } get(index: number): T | undefined { if (index < 0 || index >= this.size) return undefined; return this.buffer[(this.head + index) % this.capacity]; } isFull(): boolean { return this.size === this.capacity; } isEmpty(): boolean { return this.size === 0; } },Useful
This function does something with functions,"def custom_partial(func, *partial_args, **partial_kwargs): def wrapper(*args, **kwargs): new_kwargs = partial_kwargs.copy() new_kwargs.update(kwargs) return func(*partial_args, *args, **new_kwargs) return wrapper",Not Useful
Implements the merge sort algorithm for sorting arrays,fn merge_sort<T: Ord + Clone>(arr: &mut [T]) { if arr.len() <= 1 { return; } let mid = arr.len() / 2; merge_sort(&mut arr[..mid]); merge_sort(&mut arr[mid..]); let mut left = arr[..mid].to_vec(); let mut right = arr[mid..].to_vec(); let mut i = 0; let mut j = 0; let mut k = 0; while i < left.len() && j < right.len() { if left[i] <= right[j] { arr[k] = left[i].clone(); i += 1; } else { arr[k] = right[j].clone(); j += 1; } k += 1; } while i < left.len() { arr[k] = left[i].clone(); i += 1; k += 1; } while j < right.len() { arr[k] = right[j].clone(); j += 1; k += 1; } },Useful
Implements an asynchronous queue with push and pop operations,class AsyncQueue { private queue: any[] = []; private waiters: ((value: any) => void)[] = []; async push(item: any) { if (this.waiters.length > 0) { const waiter = this.waiters.shift()!; waiter(item); } else { this.queue.push(item); } } async pop(): Promise<any> { if (this.queue.length > 0) { return this.queue.shift(); } else { return new Promise((resolve) => { this.waiters.push(resolve); }); } } },Useful
Implements a custom zip function that combines multiple iterables,def custom_zip(*iterables): iterators = [iter(it) for it in iterables] while iterators: result = [] for it in iterators: try: result.append(next(it)) except StopIteration: return yield tuple(result),Useful
Implements a thread pool for efficient task execution in multi-threaded environments,"template <typename T> class ThreadPool { private: std::vector<std::thread> workers; std::queue<T> tasks; std::mutex queue_mutex; std::condition_variable condition; bool stop; public: ThreadPool(size_t threads) : stop(false) { for(size_t i = 0; i < threads; ++i) workers.emplace_back([this] { for(;;) { T task; { std::unique_lock<std::mutex> lock(this->queue_mutex); this->condition.wait(lock, [this]{ return this->stop || !this->tasks.empty(); }); if(this->stop && this->tasks.empty()) return; task = std::move(this->tasks.front()); this->tasks.pop(); } task(); } }); } template<class F> void enqueue(F&& f) { { std::unique_lock<std::mutex> lock(queue_mutex); tasks.emplace(std::forward<F>(f)); } condition.notify_one(); } ~ThreadPool() { { std::unique_lock<std::mutex> lock(queue_mutex); stop = true; } condition.notify_all(); for(std::thread &worker: workers) worker.join(); } };",Useful
Flattens a nested list structure into a single-level list,"def custom_flatten(nested_list): def flatten_helper(lst, result): for item in lst: if isinstance(item, list): flatten_helper(item, result) else: result.append(item) return result return flatten_helper(nested_list, [])",Useful
Implements a lazy property decorator for on-demand attribute computation,"class LazyProperty: def __init__(self, func): self.func = func def __get__(self, instance, cls): if instance is None: return self value = self.func(instance) setattr(instance, self.func.__name__, value) return value",Useful
This function does something with iterators,"fn custom_fold<F, T, B>(f: F, init: B, iter: impl Iterator<Item = T>) -> B where F: Fn(B, T) -> B { let mut accum = init; for item in iter { accum = f(accum, item); } accum }",Not Useful
Implements the Observer pattern for event-driven programming,class Observable { constructor() { this.observers = []; } subscribe(fn) { this.observers.push(fn); } unsubscribe(fn) { this.observers = this.observers.filter(subscriber => subscriber !== fn); } notify(data) { this.observers.forEach(observer => observer(data)); } },Useful
Creates a memoized version of a function to cache results,def custom_memoize(func): cache = {} def memoized(*args): if args not in cache: cache[args] = func(*args) return cache[args] return memoized,Useful
Implements a Skip List data structure for efficient searching and insertion,"template <typename T> class SkipList { private: struct Node { T value; std::vector<Node*> forward; Node(T v, int level) : value(v), forward(level, nullptr) {} }; Node* head; int max_level; float p; int level; int random_level() { int lvl = 1; while ((static_cast<float>(rand()) / RAND_MAX) < p && lvl < max_level) { lvl++; } return lvl; } public: SkipList(int max_lvl = 32, float prob = 0.5) : max_level(max_lvl), p(prob), level(0) { head = new Node(T(), max_level); } void insert(T value) { std::vector<Node*> update(max_level, nullptr); Node* current = head; for (int i = level - 1; i >= 0; i--) { while (current->forward[i] && current->forward[i]->value < value) { current = current->forward[i]; } update[i] = current; } int new_level = random_level(); if (new_level > level) { for (int i = level; i < new_level; i++) { update[i] = head; } level = new_level; } Node* new_node = new Node(value, new_level); for (int i = 0; i < new_level; i++) { new_node->forward[i] = update[i]->forward[i]; update[i]->forward[i] = new_node; } } bool search(T value) { Node* current = head; for (int i = level - 1; i >= 0; i--) { while (current->forward[i] && current->forward[i]->value < value) { current = current->forward[i]; } } current = current->forward[0]; return (current && current->value == value); } void remove(T value) { std::vector<Node*> update(max_level, nullptr); Node* current = head; for (int i = level - 1; i >= 0; i--) { while (current->forward[i] && current->forward[i]->value < value) { current = current->forward[i]; } update[i] = current; } current = current->forward[0]; if (current && current->value == value) { for (int i = 0; i < level; i++) { if (update[i]->forward[i] != current) { break; } update[i]->forward[i] = current->forward[i]; } delete current; while (level > 1 && head->forward[level - 1] == nullptr) { level--; } } } };",Useful
Demonstrates the use of async generators in JavaScript,"async function* asyncGenerator(start, end) { for (let i = start; i <= end; i++) { await new Promise(resolve => setTimeout(resolve, 1000)); yield i; } } async function useAsyncGenerator() { for await (const num of asyncGenerator(1, 5)) { console.log(num); } }",Useful
Implements a priority queue using a binary heap in Rust,"pub struct PriorityQueue<T: Ord> { heap: Vec<T>, } impl<T: Ord> PriorityQueue<T> { pub fn new() -> Self { PriorityQueue { heap: Vec::new() } } pub fn push(&mut self, item: T) { self.heap.push(item); self.sift_up(self.heap.len() - 1); } pub fn pop(&mut self) -> Option<T> { if self.heap.is_empty() { None } else { let last = self.heap.pop().unwrap(); if !self.heap.is_empty() { let item = std::mem::replace(&mut self.heap[0], last); self.sift_down(0); Some(item) } else { Some(last) } } } fn sift_up(&mut self, mut index: usize) { while index > 0 { let parent = (index - 1) / 2; if self.heap[index] > self.heap[parent] { self.heap.swap(index, parent); index = parent; } else { break; } } } fn sift_down(&mut self, mut index: usize) { let len = self.heap.len(); loop { let left_child = 2 * index + 1; let right_child = 2 * index + 2; let mut largest = index; if left_child < len && self.heap[left_child] > self.heap[largest] { largest = left_child; } if right_child < len && self.heap[right_child] > self.heap[largest] { largest = right_child; } if largest != index { self.heap.swap(index, largest); index = largest; } else { break; } } } }",Useful
Implements the Singleton design pattern in Python,"class Singleton: _instance = None def __new__(cls): if cls._instance is None: cls._instance = super().__new__(cls) cls._instance.initialize() return cls._instance def initialize(self): self.data = {} def set_data(self, key, value): self.data[key] = value def get_data(self, key): return self.data.get(key)",Useful
Creates a debounced function that delays invoking func until after wait milliseconds,"function debounce(func, wait) { let timeout; return function executedFunction(...args) { const later = () => { clearTimeout(timeout); func(...args); }; clearTimeout(timeout); timeout = setTimeout(later, wait); }; }",Useful
Implements a Least Frequently Used (LFU) cache with O(1) time complexity for get and put operations,"template <typename K, typename V> class LFUCache { private: int capacity; int minFreq; unordered_map<K, pair<V, int>> keyVal; unordered_map<K, list<K>::iterator> keyIter; unordered_map<int, list<K>> freqKeys; public: LFUCache(int cap) : capacity(cap), minFreq(0) {} V get(K key) { if (keyVal.count(key) == 0) return V(); int freq = keyVal[key].second; freqKeys[freq].erase(keyIter[key]); freq++; freqKeys[freq].push_front(key); keyIter[key] = freqKeys[freq].begin(); keyVal[key].second = freq; if (freqKeys[minFreq].empty()) minFreq++; return keyVal[key].first; } void put(K key, V value) { if (capacity <= 0) return; if (get(key) != V()) { keyVal[key].first = value; return; } if (keyVal.size() >= capacity) { K evictKey = freqKeys[minFreq].back(); keyVal.erase(evictKey); keyIter.erase(evictKey); freqKeys[minFreq].pop_back(); } keyVal[key] = {value, 1}; freqKeys[1].push_front(key); keyIter[key] = freqKeys[1].begin(); minFreq = 1; } };",Useful
This function does something with iterables,def custom_chain(*iterables): for it in iterables: yield from it,Not Useful
Transforms a function operating on words to one operating on indices in the vocabulary.,"def conjugate(self, f):
    return lambda i: self.word_index[f(self.index_word[i])]",Useful
"Splits the dataset into test, validation, and training sets based on repository IDs.","test = empty | df.repo_id.map(test_repos.__contains__)
valid = ~empty & df.repo_id.map(valid_repos.__contains__)
train = ~valid & ~test",Useful
Applies rotary positional embeddings to the input tensor.,"def apply_rotary_emb(x, rope):
    return (x * rope[..., :x.shape[-1]//2]) + (x * rope[..., x.shape[-1]//2:].roll(shifts=1, dims=-1))",Useful
This function reads data from a file.,"fn process_chunk<R: Read>(reader: &mut R, chunk_size: usize) -> Result<Vec<u8>, std::io::Error> {
    let mut buffer = vec![0; chunk_size];
    let bytes_read = reader.read(&mut buffer)?;
    buffer.truncate(bytes_read);
    Ok(buffer)
}",Not Useful
Implements a lock-free queue using atomic operations for thread-safe concurrent access.,"template<typename T>
class LockFreeQueue {
private:
    struct Node {
        T data;
        std::atomic<Node*> next;
        Node(const T& val) : data(val), next(nullptr) {}
    };
    std::atomic<Node*> head;
    std::atomic<Node*> tail;
public:
    LockFreeQueue() {
        Node* dummy = new Node(T());
        head.store(dummy);
        tail.store(dummy);
    }
    void enqueue(const T& val) {
        Node* new_node = new Node(val);
        while (true) {
            Node* last = tail.load();
            Node* next = last->next.load();
            if (last == tail.load()) {
                if (next == nullptr) {
                    if (last->next.compare_exchange_weak(next, new_node)) {
                        tail.compare_exchange_weak(last, new_node);
                        return;
                    }
                } else {
                    tail.compare_exchange_weak(last, next);
                }
            }
        }
    }
};",Useful
Fetches data from a URL with exponential backoff retry logic.,"async function fetchWithRetry(url, options = {}, maxRetries = 3) {
  let retries = 0;
  while (retries < maxRetries) {
    try {
      const response = await fetch(url, options);
      if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      return await response.json();
    } catch (error) {
      retries++;
      if (retries === maxRetries) throw error;
      await new Promise(resolve => setTimeout(resolve, 1000 * Math.pow(2, retries)));
    }
  }
}",Useful
This decorator caches function results.,"def memoize(func):
    cache = {}
    def wrapper(*args, **kwargs):
        key = str(args) + str(kwargs)
        if key not in cache:
            cache[key] = func(*args, **kwargs)
        return cache[key]
    return wrapper",Not Useful
"Parses a log entry string into a structured LogEntry object, handling potential parsing errors.","fn parse_log_entry(entry: &str) -> Result<LogEntry, ParseError> {
    let parts: Vec<&str> = entry.split('|').collect();
    if parts.len() != 4 {
        return Err(ParseError::InvalidFormat);
    }
    Ok(LogEntry {
        timestamp: NaiveDateTime::parse_from_str(parts[0], ""%Y-%m-%d %H:%M:%S"")?,
        level: parts[1].parse()?,
        module: parts[2].to_string(),
        message: parts[3].to_string(),
    })
}",Useful
Implements a lazy-loading property descriptor that computes the value only when first accessed.,"class LazyProperty:
    def __init__(self, func):
        self.func = func

    def __get__(self, instance, cls):
        if instance is None:
            return self
        value = self.func(instance)
        setattr(instance, self.func.__name__, value)
        return value",Useful
This class implements a circular buffer.,"template <typename T, size_t N>
class RingBuffer {
private:
    std::array<T, N> buffer;
    size_t head = 0;
    size_t tail = 0;
    bool full = false;

public:
    void push(const T& item) {
        buffer[head] = item;
        if (full) {
            tail = (tail + 1) % N;
        }
        head = (head + 1) % N;
        full = head == tail;
    }

    T pop() {
        if (empty()) {
            throw std::out_of_range(""Buffer is empty"");
        }
        auto val = buffer[tail];
        full = false;
        tail = (tail + 1) % N;
        return val;
    }

    bool empty() const { return (!full && (head == tail)); }
    bool full() const { return full; }
    size_t size() const { return full ? N : (head - tail) % N; }
};",Not Useful
Implements a trie data structure for efficient prefix-based word lookup and autocompletion.,"def create_trie(words):
    trie = {}
    for word in words:
        node = trie
        for char in word:
            node = node.setdefault(char, {})
        node['$'] = True
    return trie

def autocomplete(trie, prefix):
    node = trie
    for char in prefix:
        if char not in node:
            return []
        node = node[char]
    return list(find_words(node, prefix))

def find_words(node, prefix):
    if '$' in node:
        yield prefix
    for char, child in node.items():
        if char != '$':
            yield from find_words(child, prefix + char)",Useful
Applies a function to each element of a slice in parallel using Rayon.,"fn parallel_map<T, U, F>(input: &[T], f: F) -> Vec<U>
where
    T: Send + Sync,
    U: Send,
    F: Fn(&T) -> U + Send + Sync,
{
    use rayon::prelude::*;
    input.par_iter().map(f).collect()
}",Useful
This class ensures only one instance is created.,"class Singleton:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance",Not Useful
Calculates the Levenshtein distance between two strings using dynamic programming.,"def levenshtein_distance(s1, s2):
    if len(s1) < len(s2):
        return levenshtein_distance(s2, s1)
    if len(s2) == 0:
        return len(s1)
    previous_row = range(len(s2) + 1)
    for i, c1 in enumerate(s1):
        current_row = [i + 1]
        for j, c2 in enumerate(s2):
            insertions = previous_row[j + 1] + 1
            deletions = current_row[j] + 1
            substitutions = previous_row[j] + (c1 != c2)
            current_row.append(min(insertions, deletions, substitutions))
        previous_row = current_row
    return previous_row[-1]",Useful
Fetches multiple URLs with rate limiting and concurrency control.,"async function rateLimitedFetch(urls, concurrency = 5, delay = 1000) {
  const queue = urls.map((url, index) => ({ url, index }));
  const results = new Array(urls.length);
  const workers = new Array(concurrency).fill(null).map(async () => {
    while (queue.length) {
      const { url, index } = queue.shift();
      try {
        const response = await fetch(url);
        results[index] = await response.json();
      } catch (error) {
        results[index] = { error: error.message };
      }
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  });
  await Promise.all(workers);
  return results;
}",Useful
Implements a thread-safe queue with blocking and non-blocking pop operations.,"template <typename T>
class ThreadSafeQueue {
private:
    std::queue<T> queue;
    mutable std::mutex mutex;
    std::condition_variable cond;

public:
    void push(T item) {
        std::lock_guard<std::mutex> lock(mutex);
        queue.push(std::move(item));
        cond.notify_one();
    }

    T pop() {
        std::unique_lock<std::mutex> lock(mutex);
        cond.wait(lock, [this] { return !queue.empty(); });
        T item = std::move(queue.front());
        queue.pop();
        return item;
    }

    bool try_pop(T& item) {
        std::lock_guard<std::mutex> lock(mutex);
        if (queue.empty()) {
            return false;
        }
        item = std::move(queue.front());
        queue.pop();
        return true;
    }

    bool empty() const {
        std::lock_guard<std::mutex> lock(mutex);
        return queue.empty();
    }
};",Useful
This decorator adds caching to a function.,"def lru_cache(maxsize=128):
    def decorator(func):
        cache = OrderedDict()
        @wraps(func)
        def wrapper(*args, **kwargs):
            key = str(args) + str(kwargs)
            if key not in cache:
                if len(cache) >= maxsize:
                    cache.popitem(last=False)
                cache[key] = func(*args, **kwargs)
            else:
                cache.move_to_end(key)
            return cache[key]
        return wrapper
    return decorator",Not Useful
Implements the merge sort algorithm for sorting slices in Rust.,"fn merge_sort<T: Ord + Clone>(arr: &mut [T]) {
    if arr.len() <= 1 {
        return;
    }
    let mid = arr.len() / 2;
    merge_sort(&mut arr[..mid]);
    merge_sort(&mut arr[mid..]);
    let mut left = arr[..mid].to_vec();
    let mut right = arr[mid..].to_vec();
    let mut i = 0;
    let mut j = 0;
    let mut k = 0;
    while i < left.len() && j < right.len() {
        if left[i] <= right[j] {
            arr[k] = left[i].clone();
            i += 1;
        } else {
            arr[k] = right[j].clone();
            j += 1;
        }
        k += 1;
    }
    while i < left.len() {
        arr[k] = left[i].clone();
        i += 1;
        k += 1;
    }
    while j < right.len() {
        arr[k] = right[j].clone();
        j += 1;
        k += 1;
    }
}",Useful
Implements the Observer pattern for event-driven programming.,"class Observable:
    def __init__(self):
        self._observers = []

    def attach(self, observer):
        if observer not in self._observers:
            self._observers.append(observer)

    def detach(self, observer):
        try:
            self._observers.remove(observer)
        except ValueError:
            pass

    def notify(self, *args, **kwargs):
        for observer in self._observers:
            observer.update(self, *args, **kwargs)

class Observer:
    def update(self, observable, *args, **kwargs):
        pass",Useful
This decorator limits the rate of function calls.,"def throttle(wait):
    def decorator(fn):
        last_called = 0
        def wrapper(*args, **kwargs):
            nonlocal last_called
            now = time.time()
            if now - last_called >= wait:
                last_called = now
                return fn(*args, **kwargs)
        return wrapper
    return decorator",Not Useful
"Creates an iterator that parses a JSON stream, handling potential errors for each parsed value.","fn parse_json_stream<R: Read>(reader: R) -> impl Iterator<Item = Result<Value, serde_json::Error>> {
    let stream = serde_json::Deserializer::from_reader(reader).into_iter::<Value>();
    stream.map(|item| {
        item.map_err(|err| {
            serde_json::Error::custom(format!(""JSON parsing error: {}"", err))
        })
    })
}",Useful
"Implements a priority queue with efficient add, remove, and pop operations using a heap.","class PriorityQueue:
    def __init__(self):
        self.heap = []
        self.entry_finder = {}
        self.REMOVED = '<removed-task>'
        self.counter = itertools.count()

    def add_task(self, task, priority=0):
        if task in self.entry_finder:
            self.remove_task(task)
        count = next(self.counter)
        entry = [priority, count, task]
        self.entry_finder[task] = entry
        heapq.heappush(self.heap, entry)

    def remove_task(self, task):
        entry = self.entry_finder.pop(task)
        entry[-1] = self.REMOVED

    def pop_task(self):
        while self.heap:
            priority, count, task = heapq.heappop(self.heap)
            if task is not self.REMOVED:
                del self.entry_finder[task]
                return task
        raise KeyError('pop from an empty priority queue')

    def __len__(self):
        return len(self.entry_finder)",Useful
Implements a coroutine-based pattern matching system using Python generators.,"def coroutine(func):
    @wraps(func)
    def primer(*args, **kwargs):
        gen = func(*args, **kwargs)
        next(gen)
        return gen
    return primer

@coroutine
def grep(pattern):
    print(f""Looking for {pattern}"")
    try:
        while True:
            line = yield
            if pattern in line:
                print(line)
    except GeneratorExit:
        print(""Coroutine is closing"")",Useful
Implements a custom Promise class with basic functionality similar to the native JavaScript Promise.,"class Promise {
  constructor(executor) {
    this.state = 'pending';
    this.value = undefined;
    this.reason = undefined;
    this.onFulfilledCallbacks = [];
    this.onRejectedCallbacks = [];

    const resolve = (value) => {
      if (this.state === 'pending') {
        this.state = 'fulfilled';
        this.value = value;
        this.onFulfilledCallbacks.forEach(callback => callback(value));
      }
    };

    const reject = (reason) => {
      if (this.state === 'pending') {
        this.state = 'rejected';
        this.reason = reason;
        this.onRejectedCallbacks.forEach(callback => callback(reason));
      }
    };

    try {
      executor(resolve, reject);
    } catch (error) {
      reject(error);
    }
  }

  then(onFulfilled, onRejected) {
    return new Promise((resolve, reject) => {
      if (this.state === 'fulfilled') {
        setTimeout(() => {
          try {
            const result = onFulfilled(this.value);
            resolve(result);
          } catch (error) {
            reject(error);
          }
        }, 0);
      } else if (this.state === 'rejected') {
        setTimeout(() => {
          try {
            const result = onRejected(this.reason);
            resolve(result);
          } catch (error) {
            reject(error);
          }
        }, 0);
      } else {
        this.onFulfilledCallbacks.push((value) => {
          setTimeout(() => {
            try {
              const result = onFulfilled(value);
              resolve(result);
            } catch (error) {
              reject(error);
            }
          }, 0);
        });
        this.onRejectedCallbacks.push((reason) => {
          setTimeout(() => {
            try {
              const result = onRejected(reason);
              resolve(result);
            } catch (error) {
              reject(error);
            }
          }, 0);
        });
      }
    });
  }

  catch(onRejected) {
    return this.then(null, onRejected);
  }
}",Useful
This function parses a log line.,"fn parse_log_line(line: &str) -> Result<LogEntry, ParseError> {
    let parts: Vec<&str> = line.splitn(4, ' ').collect();
    if parts.len() != 4 {
        return Err(ParseError::InvalidFormat);
    }
    
    let timestamp = NaiveDateTime::parse_from_str(parts[0], ""%Y-%m-%d %H:%M:%S"")
        .map_err(|_| ParseError::InvalidTimestamp)?;
    
    let level = match parts[1] {
        ""ERROR"" => LogLevel::Error,
        ""WARN"" => LogLevel::Warn,
        ""INFO"" => LogLevel::Info,
        ""DEBUG"" => LogLevel::Debug,
        _ => return Err(ParseError::InvalidLogLevel),
    };
    
    let module = parts[2].to_string();
    let message = parts[3].to_string();
    
    Ok(LogEntry {
        timestamp,
        level,
        module,
        message,
    })
}",Not Useful
"Implements a circular buffer (ring buffer) in TypeScript with efficient push, pop, and random access operations.","class CircularBuffer<T> {
    private buffer: T[];
    private head: number = 0;
    private tail: number = 0;
    private size: number = 0;

    constructor(private capacity: number) {
        this.buffer = new Array<T>(capacity);
    }

    push(item: T): void {
        if (this.size === this.capacity) {
            this.head = (this.head + 1) % this.capacity;
        } else {
            this.size++;
        }
        this.buffer[this.tail] = item;
        this.tail = (this.tail + 1) % this.capacity;
    }

    pop(): T | undefined {
        if (this.size === 0) return undefined;
        const item = this.buffer[this.head];
        this.head = (this.head + 1) % this.capacity;
        this.size--;
        return item;
    }

    get(index: number): T | undefined {
        if (index < 0 || index >= this.size) return undefined;
        return this.buffer[(this.head + index) % this.capacity];
    }

    isFull(): boolean {
        return this.size === this.capacity;
    }

    isEmpty(): boolean {
        return this.size === 0;
    }

    clear(): void {
        this.head = 0;
        this.tail = 0;
        this.size = 0;
    }
}",Useful
This function creates a binary search tree.,"def create_balanced_bst(sorted_array):
    if not sorted_array:
        return None
    mid = len(sorted_array) // 2
    root = TreeNode(sorted_array[mid])
    root.left = create_balanced_bst(sorted_array[:mid])
    root.right = create_balanced_bst(sorted_array[mid+1:])
    return root",Not Useful
Implements a parallel quicksort algorithm using Rayon for efficient multi-threaded sorting.,"fn parallel_quicksort<T: Send + Ord>(v: &mut [T]) {
    if v.len() <= 1 {
        return;
    }
    let mid = partition(v);
    let (left, right) = v.split_at_mut(mid);
    rayon::join(|| parallel_quicksort(left),
                || parallel_quicksort(right));
}

fn partition<T: Ord>(v: &mut [T]) -> usize {
    let pivot = v.len() - 1;
    let mut i = 0;
    for j in 0..pivot {
        if v[j] <= v[pivot] {
            v.swap(i, j);
            i += 1;
        }
    }
    v.swap(i, pivot);
    i
}",Useful
Implements an LRU (Least Recently Used) cache with O(1) time complexity for get and put operations.,"class LRUCache:
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = OrderedDict()

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        self.cache.move_to_end(key)
        return self.cache[key]

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            self.cache.move_to_end(key)
        self.cache[key] = value
        if len(self.cache) > self.capacity:
            self.cache.popitem(last=False)

    def __len__(self):
        return len(self.cache)

    def clear(self):
        self.cache.clear()",Useful
This function creates a custom iterator.,"fn custom_iterator<I, T>(iter: I) -> impl Iterator<Item = T>
where
    I: Iterator<Item = T>,
    T: Clone,
{
    iter.scan(Vec::new(), |state, item| {
        state.push(item.clone());
        Some(state.clone())
    })
    .flat_map(|v| v.into_iter())
}",Not Useful
"Implements an asynchronous event emitter with support for adding, removing, and emitting events with async listeners.","class AsyncEventEmitter {
    constructor() {
        this.listeners = new Map();
    }

    on(event, listener) {
        if (!this.listeners.has(event)) {
            this.listeners.set(event, []);
        }
        this.listeners.get(event).push(listener);
    }

    off(event, listener) {
        if (!this.listeners.has(event)) return;
        const eventListeners = this.listeners.get(event);
        const index = eventListeners.indexOf(listener);
        if (index !== -1) {
            eventListeners.splice(index, 1);
        }
    }

    async emit(event, ...args) {
        if (!this.listeners.has(event)) return;
        const eventListeners = this.listeners.get(event);
        await Promise.all(eventListeners.map(listener => listener(...args)));
    }

    once(event, listener) {
        const onceWrapper = async (...args) => {
            await listener(...args);
            this.off(event, onceWrapper);
        };
        this.on(event, onceWrapper);
    }
}",Useful
Calculates the edit distance between two strings using dynamic programming.,"def compute_edit_distance(s1: str, s2: str) -> int:
    m, n = len(s1), len(s2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    for i in range(m + 1):
        dp[i][0] = i
    for j in range(n + 1):
        dp[0][j] = j
    
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i-1] == s2[j-1]:
                dp[i][j] = dp[i-1][j-1]
            else:
                dp[i][j] = 1 + min(dp[i-1][j],      # deletion
                                   dp[i][j-1],      # insertion
                                   dp[i-1][j-1])    # substitution
    
    return dp[m][n]",Useful
This class implements a data structure.,"class FenwickTree {
    private tree: number[];

    constructor(n: number) {
        this.tree = new Array(n + 1).fill(0);
    }

    update(i: number, delta: number): void {
        while (i < this.tree.length) {
            this.tree[i] += delta;
            i += i & (-i);
        }
    }

    prefixSum(i: number): number {
        let sum = 0;
        while (i > 0) {
            sum += this.tree[i];
            i -= i & (-i);
        }
        return sum;
    }

    rangeSum(left: number, right: number): number {
        return this.prefixSum(right) - this.prefixSum(left - 1);
    }
}",Not Useful
Implements a search functionality using an inverted index.,"def tokenize(text):
    words = text.lower().split()
    return [word.strip('.,!?()[]{}') for word in words]

def build_inverted_index(documents):
    inverted_index = defaultdict(set)
    for doc_id, doc in enumerate(documents):
        for word in tokenize(doc):
            inverted_index[word].add(doc_id)
    return inverted_index

def search(query, inverted_index, documents):
    query_terms = tokenize(query)
    results = set.intersection(*[inverted_index[term] for term in query_terms if term in inverted_index])",Useful
Implements a binary tree with insertion functionality.,"class BinaryTreeNode:
    def __init__(self, key):
        self.left = None
        self.right = None
        self.val = key

class BinaryTree:
    def __init__(self):
        self.root = None

    def insert(self, key):
        if self.root is None:
            self.root = BinaryTreeNode(key)
        else:
            self._insert_recursively(self.root, key)

    def _insert_recursively(self, node, key):
        if key < node.val:
            if node.left is None:
                node.left = BinaryTreeNode(key)
            else:
                self._insert_recursively(node.left, key)
        else:
            if node.right is None:
                node.right = BinaryTreeNode(key)
            else:
                self._insert_recursively(node.right, key)",Not Useful
Transforms a function operating on strings/words to one operating on numeric indices,"def conjugate(self, f):
    return lambda i: self.word_index[f(self.index_word[i])]",Useful
"Splits the dataset into test, validation, and training sets based on repository IDs","test = empty | df.repo_id.map(test_repos.__contains__)
valid = ~empty & df.repo_id.map(valid_repos.__contains__)
train = ~valid & ~test",Useful
This function does something with caching,"def memoize(func):
    cache = {}
    def wrapper(*args):
        if args not in cache:
            cache[args] = func(*args)
        return cache[args]
    return wrapper",Not Useful
Parses a JSON configuration file into a specified Rust struct,"fn parse_config<T: DeserializeOwn>(config_path: &Path) -> Result<T, Box<dyn Error>> {
    let config_str = fs::read_to_string(config_path)?
    let config: T = serde_json::from_str(&config_str)?
    Ok(config)
}",Useful
Fetches data from a URL with exponential backoff retry mechanism,"async function fetchWithRetry(url, options = {}, maxRetries = 3) {
    for (let i = 0; i < maxRetries; i++) {
        try {
            const response = await fetch(url, options);
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            return await response.json();
        } catch (e) {
            if (i === maxRetries - 1) throw e;
            await new Promise(resolve => setTimeout(resolve, 1000 * Math.pow(2, i)));
        }
    }
}",Useful
Implements a thread-safe queue in C++ using mutex and condition variable,"template<typename T>
class ThreadSafeQueue {
private:
    std::queue<T> queue;
    mutable std::mutex mutex;
    std::condition_variable cond;

public:
    void push(T item) {
        std::unique_lock<std::mutex> lock(mutex);
        queue.push(std::move(item));
        lock.unlock();
        cond.notify_one();
    }

    T pop() {
        std::unique_lock<std::mutex> lock(mutex);
        cond.wait(lock, [this]{ return !queue.empty(); });
        T item = std::move(queue.front());
        queue.pop();
        return item;
    }
};",Useful
This function does something with generators,"def coroutine_decorator(func):
    def wrapper(*args, **kwargs):
        gen = func(*args, **kwargs)
        next(gen)
        return gen
    return wrapper

@coroutine_decorator
def grep(pattern):
    while True:
        line = yield
        if pattern in line:
            print(line)",Not Useful
Implements a parallel quicksort algorithm in Rust using the Rayon library,"fn parallel_quick_sort<T: Send + Ord>(v: &mut [T]) {
    if v.len() <= 1 {
        return;
    }
    let mid = partition(v);
    let (lo, hi) = v.split_at_mut(mid);
    rayon::join(|| parallel_quick_sort(lo),
                || parallel_quick_sort(hi));
}

fn partition<T: Ord>(v: &mut [T]) -> usize {
    let pivot = v.len() - 1;
    let mut i = 0;
    for j in 0..pivot {
        if v[j] <= v[pivot] {
            v.swap(i, j);
            i += 1;
        }
    }
    v.swap(i, pivot);
    i
}",Useful
Implements an LRU (Least Recently Used) cache in C++ using a list and unordered_map,"class LRUCache {
private:
    int capacity;
    list<pair<int, int>> cache;
    unordered_map<int, list<pair<int, int>>::iterator> map;

public:
    LRUCache(int capacity) : capacity(capacity) {}
    
    int get(int key) {
        if (map.find(key) == map.end()) return -1;
        cache.splice(cache.begin(), cache, map[key]);
        return map[key]->second;
    }
    
    void put(int key, int value) {
        if (get(key) != -1) {
            map[key]->second = value;
            return;
        }
        if (cache.size() == capacity) {
            int last = cache.back().first;
            cache.pop_back();
            map.erase(last);
        }
        cache.emplace_front(key, value);
        map[key] = cache.begin();
    }
};",Useful
This function does something with images,"def process_image(image_path):
    with Image.open(image_path) as img:
        img = img.convert('RGB')
        img = img.resize((224, 224))
        img_array = np.array(img) / 255.0
        img_tensor = tf.convert_to_tensor(img_array, dtype=tf.float32)
        img_tensor = tf.expand_dims(img_tensor, 0)
    return img_tensor",Not Useful
Demonstrates the use of async generators in JavaScript,"async function* asyncGenerator(start, end) {
    for (let i = start; i <= end; i++) {
        await new Promise(resolve => setTimeout(resolve, 1000));
        yield i;
    }
}

async function useAsyncGenerator() {
    for await (const num of asyncGenerator(1, 5)) {
        console.log(num);
    }
}",Useful
Implements a custom reduce function in Python,"def custom_reduce(function, iterable, initializer=None):
    it = iter(iterable)
    if initializer is None:
        try:
            initializer = next(it)
        except StopIteration:
            raise TypeError('reduce() of empty sequence with no initial value')
    accum_value = initializer
    for x in it:
        accum_value = function(accum_value, x)
    return accum_value",Useful
This struct does something with trees,"struct Trie {
    children: [Option<Box<Trie>>; 26],
    is_end: bool,
}

impl Trie {
    fn new() -> Self {
        Trie {
            children: Default::default(),
            is_end: false,
        }
    }
    
    fn insert(&mut self, word: String) {
        let mut node = self;
        for c in word.chars() {
            node = node.children[c as usize - 'a' as usize]
                .get_or_insert_with(|| Box::new(Trie::new()));
        }
        node.is_end = true;
    }
    
    fn search(&self, word: String) -> bool {
        self.find(word).map_or(false, |node| node.is_end)
    }
    
    fn starts_with(&self, prefix: String) -> bool {
        self.find(prefix).is_some()
    }
    
    fn find(&self, s: String) -> Option<&Trie> {
        let mut node = self;
        for c in s.chars() {
            match &node.children[c as usize - 'a' as usize] {
                Some(next) => node = next,
                None => return None,
            }
        }
        Some(node)
    }
}",Not Useful
Defines a Hashable concept and a HashMap class template in C++20,"template <typename T>
concept Hashable = requires(T a) {
    { std::hash<T>{}(a) } -> std::convertible_to<std::size_t>;
    { a == a } -> std::convertible_to<bool>;
    { a != a } -> std::convertible_to<bool>;
};

template <Hashable K, typename V>
class HashMap {
    // Implementation details...
};",Useful
Implements function currying in Python using a decorator,"def curry(func):
    def curried(*args):
        if len(args) >= func.__code__.co_argcount:
            return func(*args)
        return lambda *more_args: curried(*(args + more_args))
    return curried

@curry
def add(x, y, z):
    return x + y + z

print(add(1)(2)(3))  # Outputs: 6
print(add(1, 2)(3))  # Outputs: 6
print(add(1)(2, 3))  # Outputs: 6",Useful
Constructs a suffix array for a given string using the prefix doubling algorithm,"fn build_suffix_array(s: &str) -> Vec<usize> {
    let n = s.len();
    let mut sa: Vec<usize> = (0..n).collect();
    let mut rank: Vec<usize> = s.bytes().map(|b| b as usize).collect();
    let mut tmp = vec![0; n];
    let mut k = 1;
    while k < n {
        sa.sort_by_key(|&i| (rank[i], if i + k < n { rank[i + k] } else { 0 }));
        tmp[sa[0]] = 0;
        for i in 1..n {
            tmp[sa[i]] = tmp[sa[i - 1]]
                + ((rank[sa[i]], if sa[i] + k < n { rank[sa[i] + k] } else { 0 })
                    > (rank[sa[i - 1]], if sa[i - 1] + k < n { rank[sa[i - 1] + k] } else { 0 })) as usize;
        }
        std::mem::swap(&mut rank, &mut tmp);
        if rank[sa[n - 1]] == n - 1 {
            break;
        }
        k *= 2;
    }
    sa
}",Useful
This class does something with trees,"class FenwickTree:
    def __init__(self, n):
        self.n = n
        self.tree = [0] * (n + 1)

    def update(self, i, delta):
        while i <= self.n:
            self.tree[i] += delta
            i += i & (-i)

    def query(self, i):
        total = 0
        while i > 0:
            total += self.tree[i]
            i -= i & (-i)
        return total

    def range_query(self, left, right):
        return self.query(right) - self.query(left - 1)",Not Useful
Implements a function to count inversions in an array using merge sort,"fn count_inversions<T: Ord + Clone>(arr: &[T]) -> usize {
    fn merge_and_count<T: Ord + Clone>(left: &[T], right: &[T]) -> (Vec<T>, usize) {
        let mut result = Vec::with_capacity(left.len() + right.len());
        let mut count = 0;
        let mut i = 0;
        let mut j = 0;

        while i < left.len() && j < right.len() {
            if left[i] <= right[j] {
                result.push(left[i].clone());
                i += 1;
            } else {
                result.push(right[j].clone());
                count += left.len() - i;
                j += 1;
            }
        }

        result.extend_from_slice(&left[i..]);
        result.extend_from_slice(&right[j..]);

        (result, count)
    }

    fn merge_sort_and_count<T: Ord + Clone>(arr: &[T]) -> (Vec<T>, usize) {
        if arr.len() <= 1 {
            return (arr.to_vec(), 0);
        }

        let mid = arr.len() / 2;
        let (left, left_count) = merge_sort_and_count(&arr[..mid]);
        let (right, right_count) = merge_sort_and_count(&arr[mid..]);
        let (merged, merge_count) = merge_and_count(&left, &right);

        (merged, left_count + right_count + merge_count)
    }

    merge_sort_and_count(arr).1
}",Useful
Implements the Observer pattern in JavaScript,"class Observable {
    constructor() {
        this.observers = [];
    }

    subscribe(observer) {
        this.observers.push(observer);
    }

    unsubscribe(observer) {
        this.observers = this.observers.filter(obs => obs !== observer);
    }

    notify(data) {
        this.observers.forEach(observer => observer.update(data));
    }
}

class Observer {
    constructor(name) {
        this.name = name;
    }

    update(data) {
        console.log(`${this.name} received: ${data}`);
    }
}",Useful
This function calculates something,"def levenshtein_distance(s1, s2):
    m, n = len(s1), len(s2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(m + 1):
        dp[i][0] = i
    for j in range(n + 1):
        dp[0][j] = j

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i-1] == s2[j-1]:
                dp[i][j] = dp[i-1][j-1]
            else:
                dp[i][j] = 1 + min(dp[i-1][j],      # deletion
                                   dp[i][j-1],      # insertion
                                   dp[i-1][j-1])    # substitution

    return dp[m][n]",Not Useful
Implements a simple regex compiler in Rust,"fn compile_regex(pattern: &str) -> Result<Regex, RegexError> {
    let mut stack = Vec::new();
    let mut output = String::new();

    for c in pattern.chars() {
        match c {
            '(' => stack.push(output.len()),
            ')' => {
                if let Some(start) = stack.pop() {
                    let group = &output[start..];
                    output.truncate(start);
                    output.push_str(&format!(""(?:{})"", group));
                } else {
                    return Err(RegexError::UnbalancedParentheses);
                }
            },
            '*' | '+' | '?' => {
                if output.is_empty() || output.ends_with('(') {
                    return Err(RegexError::InvalidQuantifier);
                }
                output.push(c);
            },
            '\' => {
                output.push(c);
                if let Some(next) = pattern.chars().next() {
                    output.push(next);
                } else {
                    return Err(RegexError::TrailingBackslash);
                }
            },
            _ => output.push(c),
        }
    }

    if !stack.is_empty() {
        return Err(RegexError::UnbalancedParentheses);
    }

    Regex::new(&output)
}",Useful
Implements a Skip List data structure in C++,"template <typename T>
class SkipList {
private:
    struct Node {
        T value;
        std::vector<Node*> forward;
        Node(T v, int level) : value(v), forward(level, nullptr) {}
    };

    Node* head;
    int max_level;
    float p;
    int level;

    int random_level() {
        int lvl = 1;
        while ((float)rand()/RAND_MAX < p && lvl < max_level) {
            lvl++;
        }
        return lvl;
    }

public:
    SkipList(int max_lvl = 32, float prob = 0.5) : max_level(max_lvl), p(prob), level(0) {
        head = new Node(T(), max_level);
    }

    void insert(T value) {
        std::vector<Node*> update(max_level, nullptr);
        Node* current = head;

        for (int i = level - 1; i >= 0; i--) {
            while (current->forward[i] && current->forward[i]->value < value) {
                current = current->forward[i];
            }
            update[i] = current;
        }

        int new_level = random_level();
        if (new_level > level) {
            for (int i = level; i < new_level; i++) {
                update[i] = head;
            }
            level = new_level;
        }

        Node* new_node = new Node(value, new_level);
        for (int i = 0; i < new_level; i++) {
            new_node->forward[i] = update[i]->forward[i];
            update[i]->forward[i] = new_node;
        }
    }

    bool search(T value) {
        Node* current = head;
        for (int i = level - 1; i >= 0; i--) {
            while (current->forward[i] && current->forward[i]->value < value) {
                current = current->forward[i];
            }
        }
        current = current->forward[0];
        return current && current->value == value;
    }
};",Useful
This function does something with graphs,"def topological_sort(graph):
    def dfs(node):
        if node in visited:
            return
        visited.add(node)
        for neighbor in graph[node]:
            dfs(neighbor)
        result.append(node)

    visited = set()
    result = []
    for node in graph:
        dfs(node)
    return result[::-1]",Not Useful
Implements a parser for arithmetic expressions using the Shunting Yard algorithm in Rust,"fn parse_arithmetic_expression(expr: &str) -> Result<f64, String> {
    let mut output_queue = Vec::new();
    let mut operator_stack = Vec::new();

    for token in expr.split_whitespace() {
        match token {
            ""("" => operator_stack.push(token),
            "")"" => {
                while let Some(op) = operator_stack.pop() {
                    if op == ""("" {
                        break;
                    }
                    output_queue.push(op);
                }
            },
            ""+"" | ""-"" | ""*"" | ""/"" => {
                while let Some(op) = operator_stack.last() {
                    if op == &""("" || precedence(token) > precedence(op) {
                        break;
                    }
                    output_queue.push(operator_stack.pop().unwrap());
                }
                operator_stack.push(token);
            },
            _ => output_queue.push(token),
        }
    }

    while let Some(op) = operator_stack.pop() {
        output_queue.push(op);
    }

    let mut stack = Vec::new();
    for token in output_queue {
        match token {
            ""+"" | ""-"" | ""*"" | ""/"" => {
                let b = stack.pop().ok_or(""Invalid expression"".to_string())?;
                let a = stack.pop().ok_or(""Invalid expression"".to_string())?;
                let result = match token {
                    ""+"" => a + b,
                    ""-"" => a - b,
                    ""*"" => a * b,
                    ""/"" => a / b,
                    _ => unreachable!(),
                };
                stack.push(result);
            },
            _ => stack.push(token.parse::<f64>().map_err(|_| ""Invalid number"".to_string())?),
        }
    }

    stack.pop().ok_or(""Invalid expression"".to_string())
}

fn precedence(op: &str) -> u8 {
    match op {
        ""+"" | ""-"" => 1,
        ""*"" | ""/"" => 2,
        _ => 0,
    }
}",Useful
Implements a Lazy Segment Tree data structure in C++ for range sum queries and updates,"class LazySegmentTree {
private:
    vector<int> tree, lazy;
    int n;

    void build(vector<int>& arr, int node, int start, int end) {
        if (start == end) {
            tree[node] = arr[start];
            return;
        }
        int mid = (start + end) / 2;
        build(arr, 2*node, start, mid);
        build(arr, 2*node+1, mid+1, end);
        tree[node] = tree[2*node] + tree[2*node+1];
    }

    void propagate(int node, int start, int end) {
        if (lazy[node] != 0) {
            tree[node] += (end - start + 1) * lazy[node];
            if (start != end) {
                lazy[2*node] += lazy[node];
                lazy[2*node+1] += lazy[node];
            }
            lazy[node] = 0;
        }
    }

    void update_range(int node, int start, int end, int l, int r, int val) {
        propagate(node, start, end);
        if (start > r || end < l) return;
        if (l <= start && end <= r) {
            tree[node] += (end - start + 1) * val;
            if (start != end) {
                lazy[2*node] += val;
                lazy[2*node+1] += val;
            }
            return;
        }
        int mid = (start + end) / 2;
        update_range(2*node, start, mid, l, r, val);
        update_range(2*node+1, mid+1, end, l, r, val);
        tree[node] = tree[2*node] + tree[2*node+1];
    }

    int query_range(int node, int start, int end, int l, int r) {
        propagate(node, start, end);
        if (start > r || end < l) return 0;
        if (l <= start && end <= r) return tree[node];
        int mid = (start + end) / 2;
        return query_range(2*node, start, mid, l, r) +
               query_range(2*node+1, mid+1, end, l, r);
    }

public:
    LazySegmentTree(vector<int>& arr) {
        n = arr.size();
        tree.resize(4*n);
        lazy.resize(4*n, 0);
        build(arr, 1, 0, n-1);
    }

    void update(int l, int r, int val) {
        update_range(1, 0, n-1, l, r, val);
    }

    int query(int l, int r) {
        return query_range(1, 0, n-1, l, r);
    }
};",Useful
This function finds something,"def lcs(X, Y):
    m = len(X)
    n = len(Y)
    L = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(m + 1):
        for j in range(n + 1):
            if i == 0 or j == 0:
                L[i][j] = 0
            elif X[i-1] == Y[j-1]:
                L[i][j] = L[i-1][j-1] + 1
            else:
                L[i][j] = max(L[i-1][j], L[i][j-1])

    index = L[m][n]
    lcs = ["""" for _ in range(index)]

    i, j = m, n
    while i > 0 and j > 0:
        if X[i-1] == Y[j-1]:
            lcs[index-1] = X[i-1]
            i -= 1
            j -= 1
            index -= 1
        elif L[i-1][j] > L[i][j-1]:
            i -= 1
        else:
            j -= 1

    return """".join(lcs)",Not Useful
Implements an asynchronous queue in JavaScript with controlled concurrency,"class AsyncQueue {
    constructor() {
        this.queue = [];
        this.pendingPromise = null;
    }

    enqueue(item) {
        return new Promise(resolve => {
            this.queue.push({
                item,
                resolve
            });
            this.dequeue();
        });
    }

    async dequeue() {
        if (this.pendingPromise || this.queue.length === 0) {
            return;
        }
        this.pendingPromise = new Promise(resolve => {
            setTimeout(async () => {
                const { item, resolve: itemResolve } = this.queue.shift();
                const result = await item();
                itemResolve(result);
                this.pendingPromise = null;
                resolve();
                this.dequeue();
            }, 0);
        });
        return this.pendingPromise;
    }
}",Useful
Implements the Aho-Corasick algorithm for multiple pattern matching,"def aho_corasick(patterns):
    class TrieNode:
        def __init__(self):
            self.children = {}
            self.fail = None
            self.output = []

    root = TrieNode()

    for i, pattern in enumerate(patterns):
        node = root
        for char in pattern:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.output.append(i)

    queue = deque(root.children.values())
    while queue:
        node = queue.popleft()
        for char, child in node.children.items():
            queue.append(child)
            failure = node.fail
            while failure and char not in failure.children:
                failure = failure.fail
            child.fail = failure.children[char] if failure else root
            child.output += child.fail.output
",Useful
Implements a binary search tree insertion in C++,"struct Node {
    int data;
    Node* left;
    Node* right;
};

Node* insert(Node* root, int data) {
    if (!root) {
        Node* newNode = new Node();
        newNode->data = data;
        newNode->left = newNode->right = nullptr;
        return newNode;
    }
    if (data < root->data) {
        root->left = insert(root->left, data);
    } else {
        root->right = insert(root->right, data);
    }
    return root;
}",Useful
Implements the merge sort algorithm in Python,"def merge_sort(arr):
    if len(arr) > 1:
        mid = len(arr) // 2
        L = arr[:mid]
        R = arr[mid:]

        merge_sort(L)
        merge_sort(R)

        i = j = k = 0

        while i < len(L) and j < len(R):
            if L[i] < R[j]:
                arr[k] = L[i]
                i += 1
            else:
                arr[k] = R[j]
                j += 1
            k += 1

        while i < len(L):
            arr[k] = L[i]
            i += 1
            k += 1

        while j < len(R):
            arr[k] = R[j]
            j += 1
            k += 1
",Useful
Implements Dijkstra's algorithm for shortest paths in a graph,"fn dijkstra(graph: &Vec<Vec<(usize, usize)>>, start: usize) -> Vec<usize> {
    let n = graph.len();
    let mut dist = vec![usize::MAX; n];
    dist[start] = 0;
    let mut heap = BinaryHeap::new();
    heap.push(Reverse((0, start));

    while let Some(Reverse((cost, u))) = heap.pop() {
        if cost > dist[u] {
            continue;
        }
        for &(v, weight) in &graph[u] {
            let next = cost + weight;
            if next < dist[v] {
                dist[v] = next;
                heap.push(Reverse((next, v)));
            }
        }
    }
    dist
}",Useful
Implements binary search algorithm in Python,"def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = left + (right - left) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1",Useful
Calculates the area of a circle given its radius in Rust,"fn calculate_area(radius: f64) -> f64 {
    std::f64::consts::PI * radius * radius
}",Useful
Implements a stack data structure in Python,"class Stack:
    def __init__(self):
        self.items = []

    def push(self, item):
        self.items.append(item)

    def pop(self):
        return self.items.pop() if not self.is_empty() else None

    def is_empty(self):
        return len(self.items) == 0

    def peek(self):
        return self.items[-1] if not self.is_empty() else None",Useful
Calculates the factorial of a number recursively in Rust,"fn factorial(n: u32) -> u32 {
    if n == 0 {
        1
    } else {
        n * factorial(n - 1)
    }
}",Useful
Transforms a function operating on words to one operating on indices in a vocabulary.,"def conjugate(self, f):
    return lambda i: self.word_index[f(self.index_word[i])]",Useful
This function does something with caching.,"def memoize(func):
    cache = {}
    def wrapper(*args):
        if args not in cache:
            cache[args] = func(*args)
        return cache[args]
    return wrapper",Not Useful
"Parses a JSON configuration file, replacing escaped newlines, and deserializes it into a specified type.","fn parse_config<T: DeserializeOwn>(config_path: &Path) -> Result<T, Box<dyn Error>> {
    let config_str = fs::read_to_string(config_path)?
        .replace('\\n', ""\n"");
    let config: T = serde_json::from_str(&config_str)?;
    Ok(config)
}",Useful
Creates a debounced version of a function that delays its execution until after a specified time has elapsed since the last call.,"const debounce = (func, delay) => {
    let timeoutId;
    return (...args) => {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => func(...args), delay);
    };
};",Useful
This class implements a queue.,"template <typename T>
class ThreadSafeQueue {
private:
    std::queue<T> queue;
    mutable std::mutex mutex;
    std::condition_variable cond;

public:
    void push(T value) {
        std::lock_guard<std::mutex> lock(mutex);
        queue.push(std::move(value));
        cond.notify_one();
    }

    T pop() {
        std::unique_lock<std::mutex> lock(mutex);
        cond.wait(lock, [this] { return !queue.empty(); });
        T value = std::move(queue.front());
        queue.pop();
        return value;
    }
};",Not Useful
"Implements an exponential backoff retry mechanism for asynchronous functions, with customizable max retries and initial delay.","async function retryWithBackoff(fn, maxRetries = 5, baseDelay = 1000) {
    for (let i = 0; i < maxRetries; i++) {
        try {
            return await fn();
        } catch (error) {
            if (i === maxRetries - 1) throw error;
            await new Promise(resolve => setTimeout(resolve, baseDelay * Math.pow(2, i)));
        }
    }
}",Useful
Decorator that primes a coroutine function by advancing it to its first yield point before returning it.,"def coroutine(func):
    def start(*args, **kwargs):
        cr = func(*args, **kwargs)
        next(cr)
        return cr
    return start",Useful
This function sorts an array.,"pub fn quick_sort<T: Ord>(arr: &mut [T]) {
    if arr.len() <= 1 {
        return;
    }
    let pivot = partition(arr);
    quick_sort(&mut arr[0..pivot]);
    quick_sort(&mut arr[pivot + 1..]);
}

fn partition<T: Ord>(arr: &mut [T]) -> usize {
    let pivot = arr.len() - 1;
    let mut i = 0;
    for j in 0..pivot {
        if arr[j] <= arr[pivot] {
            arr.swap(i, j);
            i += 1;
        }
    }
    arr.swap(i, pivot);
    i
}",Not Useful
Implements a Least Recently Used (LRU) cache with constant time complexity for both get and put operations.,"class LRUCache {
private:
    int capacity;
    list<pair<int, int>> cache;
    unordered_map<int, list<pair<int, int>>::iterator> map;

public:
    LRUCache(int capacity) : capacity(capacity) {}
    
    int get(int key) {
        if (map.find(key) == map.end()) return -1;
        cache.splice(cache.begin(), cache, map[key]);
        return map[key]->second;
    }
    
    void put(int key, int value) {
        if (map.find(key) != map.end()) {
            cache.erase(map[key]);
        } else if (cache.size() == capacity) {
            map.erase(cache.back().first);
            cache.pop_back();
        }
        cache.push_front({key, value});
        map[key] = cache.begin();
    }
};",Useful
Calculates the Levenshtein distance between two strings using dynamic programming.,"def levenshtein_distance(s1, s2):
    m, n = len(s1), len(s2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    for i in range(m + 1):
        dp[i][0] = i
    for j in range(n + 1):
        dp[0][j] = j
    
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i-1] == s2[j-1]:
                dp[i][j] = dp[i-1][j-1]
            else:
                dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])
    
    return dp[m][n]",Useful
This function creates an observable object.,"const createObservable = () => {
    const observers = new Set();
    return {
        subscribe: (observer) => {
            observers.add(observer);
            return () => observers.delete(observer);
        },
        notify: (data) => observers.forEach(observer => observer(data))
    };
};",Not Useful
"Implements the Rabin-Karp string matching algorithm, returning all starting indices of pattern occurrences in the text.","pub fn rabin_karp(text: &str, pattern: &str) -> Vec<usize> {
    const BASE: u64 = 256;
    const PRIME: u64 = 101;
    
    let (n, m) = (text.len(), pattern.len());
    let mut result = Vec::new();
    if m > n { return result; }
    
    let mut pattern_hash = 0;
    let mut text_hash = 0;
    let mut h = 1;
    
    for _ in 0..m-1 {
        h = (h * BASE) % PRIME;
    }
    
    for i in 0..m {
        pattern_hash = (BASE * pattern_hash + pattern.as_bytes()[i] as u64) % PRIME;
        text_hash = (BASE * text_hash + text.as_bytes()[i] as u64) % PRIME;
    }
    
    for i in 0..=n-m {
        if pattern_hash == text_hash {
            if &text[i..i+m] == pattern {
                result.push(i);
            }
        }
        if i < n-m {
            text_hash = (BASE * (text_hash + PRIME - (text.as_bytes()[i] as u64 * h) % PRIME) % PRIME
                        + text.as_bytes()[i+m] as u64) % PRIME;
        }
    }
    
    result
}",Useful
"Decorator that transforms a function into a curried version, allowing partial application of arguments.","def curry(func):
    def curried(*args):
        if len(args) >= func.__code__.co_argcount:
            return func(*args)
        return lambda *more_args: curried(*(args + more_args))
    return curried",Useful
This class implements a buffer.,"template <typename T>
class CircularBuffer {
private:
    std::vector<T> buffer;
    size_t head = 0;
    size_t tail = 0;
    size_t max_size;
    bool full = false;

public:
    CircularBuffer(size_t size) : buffer(size), max_size(size) {}

    void push(T item) {
        buffer[head] = item;
        if (full) {
            tail = (tail + 1) % max_size;
        }
        head = (head + 1) % max_size;
        full = head == tail;
    }

    T pop() {
        if (empty()) {
            throw std::runtime_error(""Buffer is empty"");
        }
        T item = buffer[tail];
        full = false;
        tail = (tail + 1) % max_size;
        return item;
    }

    bool empty() const {
        return (!full && (head == tail));
    }

    bool full() const {
        return full;
    }

    size_t size() const {
        if (full) {
            return max_size;
        }
        if (head >= tail) {
            return head - tail;
        }
        return max_size + head - tail;
    }
};",Not Useful
"Implements a fetch function with a configurable timeout, using AbortController to cancel the request if it exceeds the specified time limit.","async function fetchWithTimeout(resource, options = {}) {
    const { timeout = 8000 } = options;
    
    const controller = new AbortController();
    const id = setTimeout(() => controller.abort(), timeout);
    
    const response = await fetch(resource, {
        ...options,
        signal: controller.signal  
    });
    clearTimeout(id);
    
    return response;
}",Useful
This function sorts a graph.,"def topological_sort(graph):
    def dfs(node):
        if node in visited:
            return
        visited.add(node)
        for neighbor in graph[node]:
            dfs(neighbor)
        result.append(node)
    
    visited = set()
    result = []
    for node in graph:
        dfs(node)
    return result[::-1]",Not Useful
"Counts the number of inversions in an array using a merge sort-based approach, with a time complexity of O(n log n).","pub fn count_inversions<T: Ord + Clone>(arr: &[T]) -> usize {
    fn merge_and_count<T: Ord + Clone>(left: &[T], right: &[T]) -> (Vec<T>, usize) {
        let mut result = Vec::with_capacity(left.len() + right.len());
        let mut inversions = 0;
        let mut i = 0;
        let mut j = 0;

        while i < left.len() && j < right.len() {
            if left[i] <= right[j] {
                result.push(left[i].clone());
                i += 1;
            } else {
                result.push(right[j].clone());
                inversions += left.len() - i;
                j += 1;
            }
        }

        result.extend_from_slice(&left[i..]);
        result.extend_from_slice(&right[j..]);

        (result, inversions)
    }

    fn merge_sort_and_count<T: Ord + Clone>(arr: &[T]) -> (Vec<T>, usize) {
        if arr.len() <= 1 {
            return (arr.to_vec(), 0);
        }

        let mid = arr.len() / 2;
        let (left, left_inv) = merge_sort_and_count(&arr[..mid]);
        let (right, right_inv) = merge_sort_and_count(&arr[mid..]);
        let (merged, merge_inv) = merge_and_count(&left, &right);

        (merged, left_inv + right_inv + merge_inv)
    }

    merge_sort_and_count(arr).1
}",Useful
This class implements a queue data structure.,"class PriorityQueue {
private:
    vector<int> heap;

    void heapifyUp(int index) {
        while (index > 0 && heap[(index - 1) / 2] < heap[index]) {
            swap(heap[index], heap[(index - 1) / 2]);
            index = (index - 1) / 2;
        }
    }

    void heapifyDown(int index) {
        int maxIndex = index;
        int leftChild = 2 * index + 1;
        int rightChild = 2 * index + 2;

        if (leftChild < heap.size() && heap[leftChild] > heap[maxIndex]) {
            maxIndex = leftChild;
        }
        if (rightChild < heap.size() && heap[rightChild] > heap[maxIndex]) {
            maxIndex = rightChild;
        }

        if (index != maxIndex) {
            swap(heap[index], heap[maxIndex]);
            heapifyDown(maxIndex);
        }
    }

public:
    void push(int value) {
        heap.push_back(value);
        heapifyUp(heap.size() - 1);
    }

    int pop() {
        if (heap.empty()) {
            throw runtime_error(""Priority queue is empty"");
        }
        int top = heap[0];
        heap[0] = heap.back();
        heap.pop_back();
        if (!heap.empty()) {
            heapifyDown(0);
        }
        return top;
    }

    bool empty() const {
        return heap.empty();
    }
};",Not Useful
Generates all possible permutations of a given sequence of elements using a recursive approach.,"def generate_permutations(elements):
    if len(elements) <= 1:
        yield elements
    else:
        for perm in generate_permutations(elements[1:]):
            for i in range(len(elements)):
                yield perm[:i] + elements[0:1] + perm[i:]",Useful
"Finds the longest increasing subsequence in an array using dynamic programming, with O(n^2) time complexity.","fn longest_increasing_subsequence(arr: &[i32]) -> Vec<i32> {
    let n = arr.len();
    let mut dp = vec![1; n];
    let mut prev = vec![None; n];

    for i in 1..n {
        for j in 0..i {
            if arr[i] > arr[j] && dp[i] < dp[j] + 1 {
                dp[i] = dp[j] + 1;
                prev[i] = Some(j);
            }
        }
    }

    let mut max_length = 0;
    let mut max_index = 0;
    for (i, &length) in dp.iter().enumerate() {
        if length > max_length {
            max_length = length;
            max_index = i;
        }
    }

    let mut result = Vec::new();
    let mut current = Some(max_index);
    while let Some(index) = current {
        result.push(arr[index]);
        current = prev[index];
    }
    result.reverse();

    result
}",Useful
This class implements a data structure for storing strings.,"class Trie {
private:
    struct TrieNode {
        unordered_map<char, unique_ptr<TrieNode>> children;
        bool is_end;
        TrieNode() : is_end(false) {}
    };
    unique_ptr<TrieNode> root;

public:
    Trie() : root(make_unique<TrieNode>()) {}
    
    void insert(string word) {
        auto node = root.get();
        for (char c : word) {
            if (!node->children[c]) {
                node->children[c] = make_unique<TrieNode>();
            }
            node = node->children[c].get();
        }
        node->is_end = true;
    }
    
    bool search(string word) {
        auto node = find(word);
        return node && node->is_end;
    }
    
    bool startsWith(string prefix) {
        return find(prefix) != nullptr;
    }

private:
    TrieNode* find(const string& prefix) {
        auto node = root.get();
        for (char c : prefix) {
            if (!node->children[c]) {
                return nullptr;
            }
            node = node->children[c].get();
        }
        return node;
    }
};",Not Useful
Implements Run-Length Encoding (RLE) compression for a given string or sequence of characters.,"def compress_rle(data):
    if not data:
        return """"
    result = []
    count = 1
    current = data[0]
    for char in data[1:]:
        if char == current:
            count += 1
        else:
            result.extend([str(count), current])
            count = 1
            current = char
    result.extend([str(count), current])
    return ''.join(result)",Useful
This function generates numbers asynchronously.,"async function* asyncGenerator(start, end, delay) {
    for (let i = start; i <= end; i++) {
        await new Promise(resolve => setTimeout(resolve, delay));
        yield i;
    }
}

async function useAsyncGenerator() {
    for await (const num of asyncGenerator(1, 5, 1000)) {
        console.log(num);
    }
}",Not Useful
"Implements the Floyd-Warshall algorithm for finding shortest paths between all pairs of vertices in a weighted graph, handling potential absence of edges.","pub fn floyd_warshall(graph: &Vec<Vec<Option<i32>>>) -> Vec<Vec<Option<i32>>> {
    let n = graph.len();
    let mut dist = graph.clone();

    for k in 0..n {
        for i in 0..n {
            for j in 0..n {
                if let (Some(ik), Some(kj)) = (dist[i][k], dist[k][j]) {
                    let new_dist = ik + kj;
                    if dist[i][j].map_or(true, |ij| new_dist < ij) {
                        dist[i][j] = Some(new_dist);
                    }
                }
            }
        }
    }

    dist
}",Useful
"Implements a Bloom filter data structure for probabilistic set membership testing, using multiple hash functions for reduced false positive rates.","class BloomFilter {
private:
    vector<bool> bits;
    vector<function<size_t(const string&)>> hash_functions;
    size_t size;

public:
    BloomFilter(size_t size, vector<function<size_t(const string&)>> hash_functions)
        : bits(size, false), hash_functions(move(hash_functions)), size(size) {}

    void add(const string& item) {
        for (const auto& hash_func : hash_functions) {
            bits[hash_func(item) % size] = true;
        }
    }

    bool might_contain(const string& item) const {
        for (const auto& hash_func : hash_functions) {
            if (!bits[hash_func(item) % size]) {
                return false;
            }
        }
        return true;
    }
};",Useful
This function multiplies two numbers.,"def karatsuba(x, y):
    if x < 10 or y < 10:
        return x * y
    
    n = max(len(str(x)), len(str(y)))
    m = n // 2
    
    high1, low1 = divmod(x, 10**m)
    high2, low2 = divmod(y, 10**m)
    
    z0 = karatsuba(low1, low2)
    z1 = karatsuba((low1 + high1), (low2 + high2))
    z2 = karatsuba(high1, high2)
    
    return (z2 * 10**(2*m)) + ((z1 - z2 - z0) * 10**m) + z0",Not Useful
"Implements the Knuth-Morris-Pratt (KMP) string matching algorithm, returning all starting positions of pattern occurrences in the text.","fn kmp_search(text: &str, pattern: &str) -> Vec<usize> {
    let text = text.as_bytes();
    let pattern = pattern.as_bytes();
    let mut lps = vec![0; pattern.len()];
    let mut len = 0;
    let mut i = 1;

    while i < pattern.len() {
        if pattern[i] == pattern[len] {
            len += 1;
            lps[i] = len;
            i += 1;
        } else if len != 0 {
            len = lps[len - 1];
        } else {
            lps[i] = 0;
            i += 1;
        }
    }

    let mut result = Vec::new();
    let mut i = 0;
    let mut j = 0;

    while i < text.len() {
        if pattern[j] == text[i] {
            i += 1;
            j += 1;
        }

        if j == pattern.len() {
            result.push(i - j);
            j = lps[j - 1];
        } else if i < text.len() && pattern[j] != text[i] {
            if j != 0 {
                j = lps[j - 1];
            } else {
                i += 1;
            }
        }
    }

    result
}",Useful
This class implements a caching mechanism.,"class LFUCache {
private:
    int capacity;
    int minFreq;
    unordered_map<int, pair<int, int>> keyVal;
    unordered_map<int, list<int>::iterator> keyList;
    unordered_map<int, list<int>> freqList;
    
    void update(int key) {
        int freq = keyVal[key].second;
        freqList[freq].erase(keyList[key]);
        freq++;
        freqList[freq].push_back(key);
        keyList[key] = --freqList[freq].end();
        keyVal[key].second = freq;
        if (freqList[minFreq].empty()) minFreq++;
    }

public:
    LFUCache(int capacity) : capacity(capacity), minFreq(0) {}
    
    int get(int key) {
        if (keyVal.count(key) == 0) return -1;
        update(key);
        return keyVal[key].first;
    }
    
    void put(int key, int value) {
        if (capacity == 0) return;
        if (keyVal.count(key)) {
            keyVal[key].first = value;
            update(key);
        } else {
            if (keyVal.size() == capacity) {
                int evict = freqList[minFreq].front();
                keyVal.erase(evict);
                keyList.erase(evict);
                freqList[minFreq].pop_front();
            }
            keyVal[key] = {value, 1};
            freqList[1].push_back(key);
            keyList[key] = --freqList[1].end();
            minFreq = 1;
        }
    }
};",Not Useful
Implements the Viterbi algorithm for finding the most likely sequence of hidden states in a Hidden Markov Model.,"def viterbi(obs, states, start_p, trans_p, emit_p):
    V = [{}]
    path = {}
    
    for y in states:
        V[0][y] = start_p[y] * emit_p[y][obs[0]]
        path[y] = [y]
    
    for t in range(1, len(obs)):
        V.append({})
        newpath = {}
        
        for y in states:
            (prob, state) = max((V[t-1][y0] * trans_p[y0][y] * emit_p[y][obs[t]], y0) for y0 in states)
            V[t][y] = prob
            newpath[y] = path[state] + [y]
        
        path = newpath
    
    (prob, state) = max((V[len(obs) - 1][y], y) for y in states)
    return (prob, path[state])",Useful
"Builds, updates, and queries a segment tree for range sum queries and point updates.","fn segment_tree_build(arr: &[i32], tree: &mut Vec<i32>, node: usize, start: usize, end: usize) {
    if start == end {
        tree[node] = arr[start];
        return;
    }
    let mid = (start + end) / 2;
    segment_tree_build(arr, tree, 2 * node, start, mid);
    segment_tree_build(arr, tree, 2 * node + 1, mid + 1, end);
    tree[node] = tree[2 * node] + tree[2 * node + 1];
}

fn segment_tree_update(tree: &mut Vec<i32>, node: usize, start: usize, end: usize, index: usize, value: i32) {
    if start == end {
        tree[node] = value;
        return;
    }
    let mid = (start + end) / 2;
    if index <= mid {
        segment_tree_update(tree, 2 * node, start, mid, index, value);
    } else {
        segment_tree_update(tree, 2 * node + 1, mid + 1, end, index, value);
    }
    tree[node] = tree[2 * node] + tree[2 * node + 1];
}

fn segment_tree_query(tree: &Vec<i32>, node: usize, start: usize, end: usize, l: usize, r: usize) -> i32 {
    if l > end || r < start {
        return 0;
    }
    if l <= start && end <= r {
        return tree[node];
    }
    let mid = (start + end) / 2;
    let left_sum = segment_tree_query(tree, 2 * node, start, mid, l, r);
",Useful
Groups an array of strings into anagrams.,"def group_anagrams(strs):
    anagrams = {}
    for s in strs:
        key = ''.join(sorted(s))
        if key in anagrams:
            anagrams[key].append(s)
        else:
            anagrams[key] = [s]
    return list(anagrams.values())",Useful
Implements binary search to find the index of a target value in a sorted array.,"fn binary_search(arr: &[i32], target: i32) -> Option<usize> {
    let mut left = 0;
    let mut right = arr.len() as isize - 1;

    while left <= right {
        let mid = (left + right) / 2;
        if arr[mid as usize] == target {
            return Some(mid as usize);
        } else if arr[mid as usize] < target {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    None
}",Useful
Implements a graph data structure with breadth-first search (BFS) traversal.,"class Graph {
private:
    unordered_map<int, list<int>> adjList;

public:
    void addEdge(int u, int v) {
        adjList[u].push_back(v);
    }

    void bfs(int start) {
        unordered_set<int> visited;
        queue<int> q;
        q.push(start);
        visited.insert(start);

        while (!q.empty()) {
            int node = q.front();
            q.pop();
            cout << node << "" "";

            for (int neighbor : adjList[node]) {
                if (visited.find(neighbor) == visited.end()) {
                    q.push(neighbor);
                    visited.insert(neighbor);
                }
            }
        }
    }
};",Useful
Checks if a string of parentheses is valid.,"def is_valid_parentheses(s):
    stack = []
    mapping = {')': '(', '}': '{', ']': '['}
    for char in s:
        if char in mapping:
            top_element = stack.pop() if stack else '#'
            if mapping[char] != top_element:
                return False
        else:
            stack.append(char)
    return not stack",Useful
Calculates the Levenshtein distance between two sequences,"fn calculate_levenshtein_distance<T: Eq>(s1: &[T], s2: &[T]) -> usize {
    let len_s1 = s1.len();
    let len_s2 = s2.len();
    let mut matrix: Vec<Vec<usize>> = vec![vec![0; len_s2 + 1]; len_s1 + 1];
    for i in 0..=len_s1 {
        matrix[i][0] = i;
    }
    for j in 0..=len_s2 {
        matrix[0][j] = j;
    }
    for (i, item1) in s1.iter().enumerate() {
        for (j, item2) in s2.iter().enumerate() {
            let cost = if item1 == item2 { 0 } else { 1 };
            matrix[i + 1][j + 1] = [
                matrix[i][j + 1] + 1,
                matrix[i + 1][j] + 1,
                matrix[i][j] + cost,
            ].iter().min().unwrap().clone();
        }
    }
    matrix[len_s1][len_s2]
}",Useful
Implements a Least Recently Used (LRU) cache with O(1) time complexity for both get and put operations,"class LRUCache {
private:
    int capacity;
    list<pair<int, int>> cache;
    unordered_map<int, list<pair<int, int>>::iterator> map;

public:
    LRUCache(int capacity) : capacity(capacity) {}
    
    int get(int key) {
        if (map.find(key) == map.end()) return -1;
        cache.splice(cache.begin(), cache, map[key]);
        return map[key]->second;
    }
    
    void put(int key, int value) {
        if (map.find(key) != map.end()) {
            cache.erase(map[key]);
        } else if (cache.size() == capacity) {
            map.erase(cache.back().first);
            cache.pop_back();
        }
        cache.push_front({key, value});
        map[key] = cache.begin();
    }
};",Useful
Fetches data with exponential backoff retry mechanism,"async function fetchWithRetry(url, options = {}, maxRetries = 3, delay = 1000) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      const response = await fetch(url, options);
      if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      return await response.json();
    } catch (error) {
      if (i === maxRetries - 1) throw error;
      await new Promise(resolve => setTimeout(resolve, delay * Math.pow(2, i)));
    }
  }
}",Useful
Decorator that caches function results to improve performance,"def memoize(func):
    cache = {}
    def wrapper(*args, **kwargs):
        key = str(args) + str(kwargs)
        if key not in cache:
            cache[key] = func(*args, **kwargs)
        return cache[key]
    return wrapper",Useful
Implements the Drop trait for a RingBuffer to properly deallocate memory,"impl<T> Drop for RingBuffer<T> {
    fn drop(&mut self) {
        if self.len == 0 {
            return;
        }
        unsafe {
            for i in 0..self.len {
                let idx = (self.head + i) % self.cap;
                ptr::drop_in_place(self.buf.add(idx));
            }
            alloc::dealloc(
                self.buf as *mut u8,
                Layout::array::<T>(self.cap).unwrap(),
            );
        }
    }
}",Useful
Parses a cron string into a structured format,"def parse_cron(cron_string):
    fields = cron_string.split()
    if len(fields) != 5:
        raise ValueError(""Invalid cron string"")
    
    parsed = {}
    for i, field in enumerate(['minute', 'hour', 'day', 'month', 'weekday']):
        parsed[field] = parse_field(fields[i], field)
    
    return parsed

def parse_field(field, name):
    ranges = {'minute': (0, 59), 'hour': (0, 23), 'day': (1, 31),
              'month': (1, 12), 'weekday': (0, 6)}
    
    if field == '*':
        return list(range(ranges[name][0], ranges[name][1] + 1))
    
    result = []
    for part in field.split(','):
        if '-' in part:
            start, end = map(int, part.split('-'))
            result.extend(range(start, end + 1))
        elif '/' in part:
            start, step = part.split('/')
            start = ranges[name][0] if start == '*' else int(start)
            result.extend(range(start, ranges[name][1] + 1, int(step)))
        else:
            result.append(int(part))
    
    return sorted(set(result))",Useful
Implements a Trie data structure for efficient string prefix operations,"class Trie:
    def __init__(self):
        self.root = {}

    def insert(self, word: str) -> None:
        node = self.root
        for char in word:
            if char not in node:
                node[char] = {}
            node = node[char]
        node['$'] = True

    def search(self, word: str) -> bool:
        node = self.root
        for char in word:
            if char not in node:
                return False
            node = node[char]
        return '$' in node

    def startsWith(self, prefix: str) -> bool:
        node = self.root
        for char in prefix:
            if char not in node:
                return False
            node = node[char]
        return True",Useful
Implements the QuickSort algorithm with in-place partitioning,"fn quick_sort<T: Ord>(arr: &mut [T]) {
    if arr.len() <= 1 {
        return;
    }
    let pivot = partition(arr);
    quick_sort(&mut arr[0..pivot]);
    quick_sort(&mut arr[pivot + 1..]);
}

fn partition<T: Ord>(arr: &mut [T]) -> usize {
    let pivot = arr.len() - 1;
    let mut i = 0;
    for j in 0..pivot {
        if arr[j] <= arr[pivot] {
            arr.swap(i, j);
            i += 1;
        }
    }
    arr.swap(i, pivot);
    i
}",Useful
Uses the Sieve of Eratosthenes to generate prime numbers up to n,"def generate_primes(n):
    sieve = [True] * (n + 1)
    sieve[0] = sieve[1] = False
    for i in range(2, int(n**0.5) + 1):
        if sieve[i]:
            for j in range(i*i, n + 1, i):
                sieve[j] = False
    return [i for i in range(2, n + 1) if sieve[i]]",Useful
Implements a circular buffer (ring buffer) with efficient push and pop operations,"class CircularBuffer<T> {
    private:
        std::vector<T> buffer;
        size_t head = 0;
        size_t tail = 0;
        size_t max_size;
        bool full = false;
    
    public:
        CircularBuffer(size_t size) : buffer(size), max_size(size) {}
        
        void push(T item) {
            buffer[head] = item;
            if (full) {
                tail = (tail + 1) % max_size;
            }
            head = (head + 1) % max_size;
            full = head == tail;
        }
        
        T pop() {
            if (empty()) {
                throw std::runtime_error(""Buffer is empty"");
            }
            auto item = buffer[tail];
            full = false;
            tail = (tail + 1) % max_size;
            return item;
        }
        
        bool empty() const {
            return (!full && (head == tail));
        }
        
        bool full() const {
            return full;
        }
        
        size_t size() const {
            if (full) {
                return max_size;
            }
            if (head >= tail) {
                return head - tail;
            }
            return max_size + head - tail;
        }
};",Useful
Implements an async throttle function to limit the rate of function calls,"async function throttle(fn, delay) {
    let lastCall = 0;
    let timeout;
    return async function(...args) {
        const now = Date.now();
        if (now - lastCall < delay) {
            clearTimeout(timeout);
            return new Promise(resolve => {
                timeout = setTimeout(() => resolve(fn.apply(this, args)), delay - (now - lastCall));
            });
        }
        lastCall = now;
        return fn.apply(this, args);
    };
}",Useful
Performs a topological sort on a directed acyclic graph using depth-first search,"def topological_sort(graph):
    def dfs(node):
        if node in visited:
            return
        visited.add(node)
        for neighbor in graph[node]:
            dfs(neighbor)
        result.append(node)
    
    visited = set()
    result = []
    for node in graph:
        dfs(node)
    return result[::-1]",Useful
Finds the maximum element in each sliding window of size k in an array,"fn sliding_window_maximum(nums: Vec<i32>, k: i32) -> Vec<i32> {
    let mut result = Vec::new();
    let mut deque = std::collections::VecDeque::new();
    
    for i in 0..nums.len() {
        if !deque.is_empty() && *deque.front().unwrap() == i as i32 - k {
            deque.pop_front();
        }
        
        while !deque.is_empty() && nums[*deque.back().unwrap() as usize] < nums[i] {
            deque.pop_back();
        }
        
        deque.push_back(i as i32);
        
        if i as i32 >= k - 1 {
            result.push(nums[*deque.front().unwrap() as usize]);
        }
    }
    
    result
}",Useful
"Implements a Bloom filter, a space-efficient probabilistic data structure","class BloomFilter:
    def __init__(self, size, hash_count):
        self.size = size
        self.hash_count = hash_count
        self.bit_array = [0] * size
    
    def _hash(self, item, seed):
        return hash((item, seed)) % self.size
    
    def add(self, item):
        for i in range(self.hash_count):
            index = self._hash(item, i)
            self.bit_array[index] = 1
    
    def __contains__(self, item):
        return all(self.bit_array[self._hash(item, i)] for i in range(self.hash_count))

    def __len__(self):
        return self.size",Useful
Creates a debounced version of a function to limit its execution frequency,"function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}",Useful
Implements the Knuth-Morris-Pratt (KMP) string matching algorithm,"fn kmp_search(text: &str, pattern: &str) -> Vec<usize> {
    let text = text.as_bytes();
    let pattern = pattern.as_bytes();
    let mut lps = vec![0; pattern.len()];
    let mut len = 0;
    let mut i = 1;
    while i < pattern.len() {
        if pattern[i] == pattern[len] {
            len += 1;
            lps[i] = len;
            i += 1;
        } else if len > 0 {
            len = lps[len - 1];
        } else {
            lps[i] = 0;
            i += 1;
        }
    }
    let mut result = Vec::new();
    let mut i = 0;
    let mut j = 0;
    while i < text.len() {
        if text[i] == pattern[j] {
            i += 1;
            j += 1;
        }
        if j == pattern.len() {
            result.push(i - j);
            j = lps[j - 1];
        } else if i < text.len() && text[i] != pattern[j] {
            if j > 0 {
                j = lps[j - 1];
            } else {
                i += 1;
            }
        }
    }
    result
}",Useful
Finds the length of the longest palindromic subsequence in a string using dynamic programming,"def longest_palindromic_subsequence(s):
    n = len(s)
    dp = [[0] * n for _ in range(n)]
    
    for i in range(n):
        dp[i][i] = 1
    
    for length in range(2, n + 1):
        for i in range(n - length + 1):
            j = i + length - 1
            if s[i] == s[j] and length == 2:
                dp[i][j] = 2
            elif s[i] == s[j]:
                dp[i][j] = dp[i+1][j-1] + 2
            else:
                dp[i][j] = max(dp[i+1][j], dp[i][j-1])
    
    return dp[0][n-1]",Useful
Implements the Union-Find data structure with path compression and union by rank optimizations,"class UnionFind {
private:
    vector<int> parent;
    vector<int> rank;

public:
    UnionFind(int n) {
        parent.resize(n);
        rank.resize(n, 0);
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
    }
    
    int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }
    
    void unite(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        if (rootX == rootY) return;
        
        if (rank[rootX] < rank[rootY]) {
            parent[rootX] = rootY;
        } else if (rank[rootX] > rank[rootY]) {
            parent[rootY] = rootX;
        } else {
            parent[rootY] = rootX;
            rank[rootX]++;
        }
    }
    
    bool connected(int x, int y) {
        return find(x) == find(y);
    }
};",Useful
Implements a Segment Tree for efficient range queries and updates on an array,"def segment_tree_build(arr):
    n = len(arr)
    tree = [0] * (4 * n)
    
    def build(node, start, end):
        if start == end:
            tree[node] = arr[start]
            return
        mid = (start + end) // 2
        build(2 * node, start, mid)
        build(2 * node + 1, mid + 1, end)
        tree[node] = tree[2 * node] + tree[2 * node + 1]
    
    build(1, 0, n - 1)
    return tree

def segment_tree_update(tree, arr, index, value):
    n = len(arr)
    
    def update(node, start, end):
        if start == end:
            tree[node] = value
            arr[index] = value
            return
        mid = (start + end) // 2
        if start <= index <= mid:
            update(2 * node, start, mid)
        else:
            update(2 * node + 1, mid + 1, end)
        tree[node] = tree[2 * node] + tree[2 * node + 1]
    
    update(1, 0, n - 1)

def segment_tree_query(tree, left, right):
    n = len(arr)
    
    def query(node, start, end):
        if right < start or end < left:
            return 0
        if left <= start and end <= right:
            return tree[node]
        mid = (start + end) // 2
        return query(2 * node, start, mid) + query(2 * node + 1, mid + 1, end)
    
    return query(1, 0, n - 1)",Useful
Implements the Rabin-Karp string matching algorithm for efficient pattern searching,"fn rabin_karp(text: &str, pattern: &str) -> Vec<usize> {
    let prime: u64 = 101;
    let mut result = Vec::new();
    let (n, m) = (text.len(), pattern.len());
    if m > n { return result; }
    
    let mut pattern_hash: u64 = 0;
    let mut text_hash: u64 = 0;
    let mut h: u64 = 1;
    
    for _ in 0..m-1 {
        h = (h * 256) % prime;
    }
    
    for i in 0..m {
        pattern_hash = (256 * pattern_hash + pattern.as_bytes()[i] as u64) % prime;
        text_hash = (256 * text_hash + text.as_bytes()[i] as u64) % prime;
    }
    
    for i in 0..=n-m {
        if pattern_hash == text_hash {
            if &text[i..i+m] == pattern {
                result.push(i);
            }
        }
        
        if i < n-m {
            text_hash = (256 * (text_hash + prime - (text.as_bytes()[i] as u64 * h) % prime) % prime
                        + text.as_bytes()[i+m] as u64) % prime;
        }
    }
    
    result
}",Useful
Implements a Least Frequently Used (LFU) cache with O(1) time complexity for both get and put operations,"class LFUCache {
private:
    int capacity;
    int minFreq;
    unordered_map<int, pair<int, int>> keyVal;
    unordered_map<int, list<int>::iterator> keyList;
    unordered_map<int, list<int>> freqList;
    
    void update(int key) {
        int freq = keyVal[key].second;
        freqList[freq].erase(keyList[key]);
        freq++;
        freqList[freq].push_back(key);
        keyList[key] = --freqList[freq].end();
        keyVal[key].second = freq;
        if (freqList[minFreq].empty()) minFreq++;
    }

public:
    LFUCache(int capacity) : capacity(capacity), minFreq(0) {}
    
    int get(int key) {
        if (keyVal.count(key) == 0) return -1;
        update(key);
        return keyVal[key].first;
    }
    
    void put(int key, int value) {
        if (capacity == 0) return;
        if (keyVal.count(key)) {
            keyVal[key].first = value;
            update(key);
        } else {
            if (keyVal.size() == capacity) {
                int evict = freqList[minFreq].front();
                keyVal.erase(evict);
                keyList.erase(evict);
                freqList[minFreq].pop_front();
            }
            keyVal[key] = {value, 1};
            freqList[1].push_back(key);
            keyList[key] = --freqList[1].end();
            minFreq = 1;
        }
    }
};",Useful
Calculates the Levenshtein distance (edit distance) between two strings using dynamic programming,"def edit_distance(s1, s2):
    m, n = len(s1), len(s2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    for i in range(m + 1):
        dp[i][0] = i
    for j in range(n + 1):
        dp[0][j] = j
    
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i-1] == s2[j-1]:
                dp[i][j] = dp[i-1][j-1]
            else:
                dp[i][j] = 1 + min(dp[i-1][j],      # Delete
                                   dp[i][j-1],      # Insert
                                   dp[i-1][j-1])    # Replace
    
    return dp[m][n]",Useful
Implements Dijkstra's algorithm for finding shortest paths in a weighted graph,"fn dijkstra(graph: &Vec<Vec<(usize, i32)>>, start: usize) -> Vec<i32> {
    let n = graph.len();
    let mut dist = vec![i32::MAX; n];
    let mut pq = std::collections::BinaryHeap::new();
    
    dist[start] = 0;
    pq.push(std::cmp::Reverse((0, start)));
    
    while let Some(std::cmp::Reverse((d, u))) = pq.pop() {
        if d > dist[u] { continue; }
        
        for &(v, w) in &graph[u] {
            if dist[u] + w < dist[v] {
                dist[v] = dist[u] + w;
                pq.push(std::cmp::Reverse((dist[v], v)));
            }
        }
    }
    
    dist
}",Useful
Computes the Z-function (or Z-algorithm) for efficient string matching,"def z_function(s):
    n = len(s)
    z = [0] * n
    l, r = 0, 0
    for i in range(1, n):
        if i <= r:
            z[i] = min(r - i + 1, z[i - l])
        while i + z[i] < n and s[z[i]] == s[i + z[i]]:
            z[i] += 1
        if i + z[i] - 1 > r:
            l, r = i, i + z[i] - 1
    return z",Useful
Implements a Segment Tree data structure for efficient range queries and point updates,"class SegmentTree {
private:
    vector<int> tree;
    int n;
    
    void build(vector<int>& arr, int v, int tl, int tr) {
        if (tl == tr) {
            tree[v] = arr[tl];
        } else {
            int tm = (tl + tr) / 2;
            build(arr, v*2, tl, tm);
            build(arr, v*2+1, tm+1, tr);
            tree[v] = tree[v*2] + tree[v*2+1];
        }
    }
    
    int sum(int v, int tl, int tr, int l, int r) {
        if (l > r) return 0;
        if (l == tl && r == tr) return tree[v];
        int tm = (tl + tr) / 2;
        return sum(v*2, tl, tm, l, min(r, tm))
             + sum(v*2+1, tm+1, tr, max(l, tm+1), r);
    }
    
    void update(int v, int tl, int tr, int pos, int new_val) {
        if (tl == tr) {
            tree[v] = new_val;
        } else {
            int tm = (tl + tr) / 2;
            if (pos <= tm)
                update(v*2, tl, tm, pos, new_val);
            else
                update(v*2+1, tm+1, tr, pos, new_val);
            tree[v] = tree[v*2] + tree[v*2+1];
        }
    }
    
public:
    SegmentTree(vector<int>& arr) {
        n = arr.size();
        tree.resize(4 * n);
        build(arr, 1, 0, n - 1);
    }
    
    int query(int l, int r) {
        return sum(1, 0, n - 1, l, r);
    }
    
    void update(int pos, int new_val) {
        update(1, 0, n - 1, pos, new_val);
    }
};",Useful
Implements Manacher's algorithm to find all palindromic substrings efficiently,"def manacher(s):
    t = '#' + '#'.join(s) + '#'
    n = len(t)
    p = [0] * n
    c = r = 0
    for i in range(n):
        if i < r:
            p[i] = min(r - i, p[2*c - i])
        while i-p[i]-1 >= 0 and i+p[i]+1 < n and t[i-p[i]-1] == t[i+p[i]+1]:
            p[i] += 1
        if i + p[i] > r:
            c, r = i, i + p[i]
    return p",Useful
Transforms a function operating on strings/words to one operating on numeric indices,"def conjugate(self, f): return lambda i: self.word_index[f(self.index_word[i])]",Useful
"Splits the dataset into test, validation, and training sets based on repository IDs",test = empty | df.repo_id.map(test_repos.__contains__); valid = ~empty & df.repo_id.map(valid_repos.__contains__); train = ~valid & ~test,Useful
This function calculates the hash value of an object,fn calculate_hash<T: Hash>(t: &T) -> u64 { let mut s = DefaultHasher::new(); t.hash(&mut s); s.finish() },Useful
Creates a memoized version of a function to improve performance,"const memoize = (fn) => { const cache = new Map(); return (...args) => { const key = JSON.stringify(args); if (cache.has(key)) return cache.get(key); const result = fn.apply(this, args); cache.set(key, result); return result; }; };",Useful
Implements a thread-safe queue using mutex and condition variable,"template<typename T> class ThreadSafeQueue { private: std::queue<T> queue; mutable std::mutex mutex; std::condition_variable cond; public: void push(T item) { std::unique_lock<std::mutex> lock(mutex); queue.push(std::move(item)); lock.unlock(); cond.notify_one(); } T pop() { std::unique_lock<std::mutex> lock(mutex); cond.wait(lock, [this]{ return !queue.empty(); }); T item = std::move(queue.front()); queue.pop(); return item; } };",Useful
Fetches data with exponential backoff retry mechanism,"async function fetchWithRetry(url, options = {}, maxRetries = 3) { for (let i = 0; i < maxRetries; i++) { try { const response = await fetch(url, options); if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`); return await response.json(); } catch (e) { if (i === maxRetries - 1) throw e; await new Promise(resolve => setTimeout(resolve, 1000 * Math.pow(2, i))); } } }",Useful
Decorator to prime a coroutine automatically,"def coroutine_decorator(func): @wraps(func) def primer(*args, **kwargs): gen = func(*args, **kwargs); next(gen); return gen; return primer",Useful
Implements the quicksort algorithm in Rust,"pub fn quick_sort<T: Ord>(arr: &mut [T]) { if arr.len() <= 1 { return; } let pivot = partition(arr); let (left, right) = arr.split_at_mut(pivot); quick_sort(left); quick_sort(&mut right[1..]); } fn partition<T: Ord>(arr: &mut [T]) -> usize { let pivot = arr.len() - 1; let mut i = 0; for j in 0..pivot { if arr[j] <= arr[pivot] { arr.swap(i, j); i += 1; } } arr.swap(i, pivot); i }",Useful
Implements a Least Recently Used (LRU) cache,"class LRUCache: def __init__(self, capacity: int): self.capacity = capacity; self.cache = OrderedDict() def get(self, key: int) -> int: if key not in self.cache: return -1; self.cache.move_to_end(key); return self.cache[key] def put(self, key: int, value: int) -> None: if key in self.cache: self.cache.move_to_end(key); self.cache[key] = value; if len(self.cache) > self.capacity: self.cache.popitem(last=False)",Useful
Implements a basic shared pointer for memory management,"template <typename T> class SharedPtr { private: T* ptr; int* refCount; public: SharedPtr(T* p = nullptr) : ptr(p), refCount(new int(1)) {} SharedPtr(const SharedPtr<T>& other) : ptr(other.ptr), refCount(other.refCount) { (*refCount)++; } SharedPtr<T>& operator=(const SharedPtr<T>& other) { if (this != &other) { release(); ptr = other.ptr; refCount = other.refCount; (*refCount)++; } return *this; } ~SharedPtr() { release(); } T& operator*() const { return *ptr; } T* operator->() const { return ptr; } private: void release() { if (--(*refCount) == 0) { delete ptr; delete refCount; } } };",Useful
This function generates prime numbers using the Sieve of Eratosthenes algorithm,"def generate_primes(n): sieve = [True] * (n + 1); sieve[0] = sieve[1] = False; for i in range(2, int(n**0.5) + 1): if sieve[i]: for j in range(i*i, n+1, i): sieve[j] = False; return [i for i in range(2, n+1) if sieve[i]]",Useful
Demonstrates the use of async generators in JavaScript,"async function* asyncGenerator(start, end) { for (let i = start; i <= end; i++) { await new Promise(resolve => setTimeout(resolve, 1000)); yield i; } } (async () => { for await (const num of asyncGenerator(1, 5)) { console.log(num); } })();",Useful
Parses a JSON string into a Rust struct,"fn parse_json<T>(input: &str) -> Result<T, serde_json::Error> where T: serde::de::DeserializeOwned { serde_json::from_str(input) }",Useful
Implements the Singleton design pattern in Python,"class Singleton: _instance = None def __new__(cls): if cls._instance is None: cls._instance = super().__new__(cls); return cls._instance def __init__(self): if not hasattr(self, 'initialized'): self.initialized = True",Useful
Implements a type-safe union using variadic templates in C++,"template<typename... Ts> struct variant_helper; template<typename F, typename... Ts> struct variant_helper<F, Ts...> { static void destroy(size_t id, void* data) { if (id == typeid(F).hash_code()) reinterpret_cast<F*>(data)->~F(); else variant_helper<Ts...>::destroy(id, data); } }; template<> struct variant_helper<> { static void destroy(size_t id, void* data) {} };",Useful
Implements function composition in JavaScript,"const compose = (...fns) => x => fns.reduceRight((y, f) => f(y), x); const add10 = x => x + 10; const multiply2 = x => x * 2; const subtract5 = x => x - 5; const composedFn = compose(subtract5, multiply2, add10); console.log(composedFn(5));",Useful
This function sorts an array,"fn bubble_sort<T: Ord + Copy>(arr: &mut [T]) { let n = arr.len(); for i in 0..n { for j in 0..n - i - 1 { if arr[j] > arr[j + 1] { arr.swap(j, j + 1); } } } }",Not Useful
Implements a thread pool for concurrent task execution in C++,"class ThreadPool { private: std::vector<std::thread> workers; std::queue<std::function<void()>> tasks; std::mutex queue_mutex; std::condition_variable condition; bool stop; public: ThreadPool(size_t threads) : stop(false) { for(size_t i = 0; i < threads; ++i) workers.emplace_back([this] { for(;;) { std::function<void()> task; { std::unique_lock<std::mutex> lock(this->queue_mutex); this->condition.wait(lock, [this]{ return this->stop || !this->tasks.empty(); }); if(this->stop && this->tasks.empty()) return; task = std::move(this->tasks.front()); this->tasks.pop(); } task(); } }); } template<class F, class... Args> auto enqueue(F&& f, Args&&... args) -> std::future<typename std::result_of<F(Args...)>::type> { using return_type = typename std::result_of<F(Args...)>::type; auto task = std::make_shared< std::packaged_task<return_type()> >(std::bind(std::forward<F>(f), std::forward<Args>(args)...)); std::future<return_type> res = task->get_future(); { std::unique_lock<std::mutex> lock(queue_mutex); if(stop) throw std::runtime_error(""enqueue on stopped ThreadPool""); tasks.emplace([task](){ (*task)(); }); } condition.notify_one(); return res; } ~ThreadPool() { { std::unique_lock<std::mutex> lock(queue_mutex); stop = true; } condition.notify_all(); for(std::thread &worker: workers) worker.join(); } };",Useful
Demonstrates a decorator with arguments in Python,"def decorator_with_arguments(arg1, arg2): def wrapper(func): @functools.wraps(func) def wrapped(*args, **kwargs): print(f""Decorator arguments: {arg1}, {arg2}""); return func(*args, **kwargs); return wrapped; return wrapper; @decorator_with_arguments(""Hello"", ""World"") def greet(name): print(f""Hello, {name}!""); greet(""Alice"")",Useful
Demonstrates trait implementation and polymorphism in Rust,"pub trait Animal { fn make_sound(&self) -> String; } pub struct Dog; pub struct Cat; impl Animal for Dog { fn make_sound(&self) -> String { String::from(""Woof!"") } } impl Animal for Cat { fn make_sound(&self) -> String { String::from(""Meow!"") } } fn animal_sounds<T: Animal>(animal: T) { println!(""{}"", animal.make_sound()); } fn main() { let dog = Dog; let cat = Cat; animal_sounds(dog); animal_sounds(cat); }",Useful
Implements the Observer pattern in JavaScript,"class Observable { constructor() { this.observers = []; } subscribe(observer) { this.observers.push(observer); } unsubscribe(observer) { this.observers = this.observers.filter(obs => obs !== observer); } notify(data) { this.observers.forEach(observer => observer.update(data)); } } class Observer { constructor(name) { this.name = name; } update(data) { console.log(`${this.name} received: ${data}`); } } const subject = new Observable(); const observer1 = new Observer('Observer 1'); const observer2 = new Observer('Observer 2'); subject.subscribe(observer1); subject.subscribe(observer2); subject.notify('Hello, observers!');",Useful
Implements bubble sort using C++20 concepts,"template <typename T> concept Sortable = requires(T a, T b) { { a < b } -> std::convertible_to<bool>; { a > b } -> std::convertible_to<bool>; { a == b } -> std::convertible_to<bool>; }; template <Sortable T> void bubble_sort(std::vector<T>& arr) { for (size_t i = 0; i < arr.size(); ++i) { for (size_t j = 0; j < arr.size() - i - 1; ++j) { if (arr[j] > arr[j + 1]) { std::swap(arr[j], arr[j + 1]); } } } }",Useful
Generates Fibonacci numbers using an async generator in JavaScript,"async function* fibonacci() { let [prev, curr] = [0, 1]; while (true) { yield curr; [prev, curr] = [curr, prev + curr]; await new Promise(resolve => setTimeout(resolve, 1000)); } } (async () => { for await (const num of fibonacci()) { console.log(num); if (num > 100) break; } })();",Useful
Implements a curry decorator in Python,"def curry(func): def curried(*args, **kwargs): if len(args) + len(kwargs) >= func.__code__.co_argcount: return func(*args, **kwargs); return lambda *more_args, **more_kwargs: curried(*args, *more_args, **kwargs, **more_kwargs); return curried; @curry def add(x, y, z): return x + y + z; print(add(1)(2)(3)); print(add(1, 2)(3)); print(add(1)(2, 3));",Useful
Implements Dijkstra's algorithm for shortest path in a graph using Rust,"pub struct Graph { edges: Vec<Vec<(usize, i32)>>, } impl Graph { pub fn new(n: usize) -> Self { Graph { edges: vec![Vec::new(); n], } } pub fn add_edge(&mut self, from: usize, to: usize, weight: i32) { self.edges[from].push((to, weight)); } pub fn dijkstra(&self, start: usize) -> Vec<i32> { let mut dist = vec![i32::MAX; self.edges.len()]; let mut heap = std::collections::BinaryHeap::new(); dist[start] = 0; heap.push(std::cmp::Reverse((0, start))); while let Some(std::cmp::Reverse((cost, node))) = heap.pop() { if cost > dist[node] { continue; } for &(next, weight) in &self.edges[node] { let next_cost = cost + weight; if next_cost < dist[next] { dist[next] = next_cost; heap.push(std::cmp::Reverse((next_cost, next))); } } } dist } }",Useful
Implements a Trie data structure for efficient string operations,"class TrieNode: def __init__(self): self.children = {}; self.is_end = False class Trie: def __init__(self): self.root = TrieNode(); def insert(self, word: str) -> None: node = self.root; for char in word: if char not in node.children: node.children[char] = TrieNode(); node = node.children[char]; node.is_end = True; def search(self, word: str) -> bool: node = self.root; for char in word: if char not in node.children: return False; node = node.children[char]; return node.is_end; def startsWith(self, prefix: str) -> bool: node = self.root; for char in prefix: if char not in node.children: return False; node = node.children[char]; return True",Useful
Implements a circular buffer (ring buffer) in C++,"template <typename T> class CircularBuffer { private: std::vector<T> buffer; size_t head = 0; size_t tail = 0; size_t max_size; bool full = false; public: CircularBuffer(size_t size) : buffer(size), max_size(size) {} void push(T item) { buffer[head] = item; if (full) { tail = (tail + 1) % max_size; } head = (head + 1) % max_size; full = head == tail; } T pop() { if (empty()) { throw std::runtime_error(""Buffer is empty""); } T item = buffer[tail]; full = false; tail = (tail + 1) % max_size; return item; } bool empty() const { return (!full && (head == tail)); } bool full() const { return full; } size_t size() const { if (full) { return max_size; } if (head >= tail) { return head - tail; } return max_size + head - tail; } };",Useful
Implements a rate limiter for asynchronous function calls in JavaScript,"async function rateLimiter(fn, limit) { const queue = []; let activeCount = 0; const executeNext = async () => { if (queue.length === 0 || activeCount >= limit) return; activeCount++; const { args, resolve, reject } = queue.shift(); try { const result = await fn(...args); resolve(result); } catch (error) { reject(error); } finally { activeCount--; executeNext(); } }; return (...args) => { return new Promise((resolve, reject) => { queue.push({ args, resolve, reject }); executeNext(); }); }; } const delay = ms => new Promise(resolve => setTimeout(resolve, ms)); const limitedFetch = rateLimiter(async (url) => { console.log(`Fetching ${url}`); await delay(1000); return `Response from ${url}`; }, 2); (async () => { const urls = ['url1', 'url2', 'url3', 'url4', 'url5']; const promises = urls.map(url => limitedFetch(url)); const results = await Promise.all(promises); console.log(results); })();",Useful
Implements Huffman coding for data compression in Python,"from typing import List, Tuple; import heapq; class HuffmanNode: def __init__(self, char: str, freq: int): self.char = char; self.freq = freq; self.left = None; self.right = None; def __lt__(self, other): return self.freq < other.freq; def build_huffman_tree(data: str) -> HuffmanNode: frequency = {}; for char in data: frequency[char] = frequency.get(char, 0) + 1; heap = [HuffmanNode(char, freq) for char, freq in frequency.items()]; heapq.heapify(heap); while len(heap) > 1: left = heapq.heappop(heap); right = heapq.heappop(heap); merged = HuffmanNode(None, left.freq + right.freq); merged.left = left; merged.right = right; heapq.heappush(heap, merged); return heap[0]; def generate_codes(root: HuffmanNode) -> dict: def traverse(node: HuffmanNode, code: str, mapping: dict): if node: if node.char: mapping[node.char] = code; traverse(node.left, code + '0', mapping); traverse(node.right, code + '1', mapping); codes = {}; traverse(root, '', codes); return codes; def huffman_encode(data: str) -> Tuple[str, dict]: root = build_huffman_tree(data); codes = generate_codes(root); encoded = ''.join(codes[char] for char in data); return encoded, codes; def huffman_decode(encoded: str, codes: dict) -> str: reversed_codes = {code: char for char, code in codes.items()}; decoded = ''; code = ''; for bit in encoded: code += bit; if code in reversed_codes: decoded += reversed_codes[code]; code = ''; return decoded; data = ""this is an example for huffman encoding""; encoded, codes = huffman_encode(data); print(f""Encoded: {encoded}""); print(f""Codes: {codes}""); decoded = huffman_decode(encoded, codes); print(f""Decoded: {decoded}""); assert data == decoded, ""Decoding failed""",Useful
Implements an LRU (Least Recently Used) cache in Rust,"use std::collections::HashMap; use std::hash::Hash; pub struct LruCache<K, V> { map: HashMap<K, V>, queue: Vec<K>, capacity: usize, } impl<K: Clone + Eq + Hash, V> LruCache<K, V> { pub fn new(capacity: usize) -> Self { LruCache { map: HashMap::with_capacity(capacity), queue: Vec::with_capacity(capacity), capacity, } } pub fn get(&mut self, key: &K) -> Option<&V> { if let Some(value) = self.map.get(key) { let index = self.queue.iter().position(|x| x == key).unwrap(); self.queue.remove(index); self.queue.push(key.clone()); Some(value) } else { None } } pub fn put(&mut self, key: K, value: V) { if self.map.contains_key(&key) { let index = self.queue.iter().position(|x| x == &key).unwrap(); this.queue.remove(index); } else if self.map.len() >= self.capacity { let old_key = this.queue.remove(0); this.map.remove(&old_key); } this.map.insert(key.clone(), value); this.queue.push(key); } } #[cfg(test)] mod tests { use super::*; #[test] fn test_lru_cache() { let mut cache = LruCache::new(2); cache.put(1, 1); cache.put(2, 2); assert_eq!(cache.get(&1), Some(&1)); cache.put(3, 3); assert_eq!(cache.get(&2), None); cache.put(4, 4); assert_eq!(cache.get(&1), None); assert_eq!(cache.get(&3), Some(&3)); assert_eq!(cache.get(&4), Some(&4)); } }",Useful
Implements a basic expression parser in Python,"class Parser: def __init__(self, text): self.text = text; self.pos = 0; def parse(self): return self.expr(); def expr(self): result = self.term(); while self.pos < len(self.text) and self.text[self.pos] in ('+', '-'): if self.text[self.pos] == '+': self.pos += 1; result += self.term(); else: self.pos += 1; result -= self.term(); return result; def term(self): result = self.factor(); while self.pos < len(self.text) and self.text[self.pos] in ('*', '/'): if self.text[self.pos] == '*': self.pos += 1; result *= self.factor(); else: self.pos += 1; result /= self.factor(); return result; def factor(self): if self.text[self.pos] == '(': self.pos += 1; result = self.expr(); self.pos += 1; return result; else: return self.number(); def number(self): start = self.pos; while self.pos < len(self.text) and self.text[self.pos].isdigit(): self.pos += 1; return int(self.text[start:self.pos])",Useful
Transforms a function on strings/words to operate on numerical indices,"def conjugate(self, f): return lambda i: self.word_index[f(self.index_word[i])]",Useful
This function creates a rotary positional embedding,"def create_rotary_embedding(self, dim: int) -> nn.Module: inv_freq = 1.0 / (10000 ** (torch.arange(0, dim, 2).float() / dim)) return nn.Parameter(inv_freq, requires_grad=False)",Not Useful
Parses a YAML configuration file into a specified Rust struct,"fn parse_config<T: DeserializeOwned>(config_path: &str) -> Result<T, Box<dyn Error>> { let config_str = fs::read_to_string(config_path)? let config: T = serde_yaml::from_str(&config_str)? Ok(config) }",Useful
Implements a thread-safe queue using mutexes and condition variables,"template<typename T> class ThreadSafeQueue { private: std::queue<T> queue; mutable std::mutex mutex; std::condition_variable cond; public: void push(T item) { std::unique_lock<std::mutex> lock(mutex); queue.push(std::move(item)); lock.unlock(); cond.notify_one(); } T pop() { std::unique_lock<std::mutex> lock(mutex); cond.wait(lock, [this]{ return !queue.empty(); }); T item = std::move(queue.front()); queue.pop(); return item; } };",Useful
Tokenizes the input text,"def custom_tokenize(text): return [token for token in re.findall(r'\w+|[^\w\s]', text) if token.strip()]",Not Useful
Performs rate-limited concurrent fetches with a specified concurrency limit,"async function rateLimitedFetch(urls, concurrency = 5) { const queue = urls.map((url, i) => ({ url, i })); const results = new Array(urls.length); const workers = new Array(concurrency).fill(null).map(async () => { while (queue.length) { const { url, i } = queue.shift(); try { const response = await fetch(url); results[i] = await response.json(); } catch (error) { results[i] = { error: error.message }; } } }); await Promise.all(workers); return results; }",Useful
Implements a parallel quicksort algorithm using Rayon,"fn parallel_quick_sort<T: Send + Ord>(mut v: Vec<T>) -> Vec<T> { if v.len() <= 1 { return v; } let pivot = v.swap_remove(0); let (left, right): (Vec<T>, Vec<T>) = v.into_iter().partition(|x| x < &pivot); let (left, right) = rayon::join(|| parallel_quick_sort(left), || parallel_quick_sort(right)); left.into_iter().chain(std::iter::once(pivot)).chain(right).collect() }",Useful
Implements an LRU (Least Recently Used) cache with constant time complexity for get and put operations,"class LRUCache { private: int capacity; list<pair<int, int>> cache; unordered_map<int, list<pair<int, int>>::iterator> map; public: LRUCache(int capacity) : capacity(capacity) {} int get(int key) { if (map.find(key) == map.end()) return -1; cache.splice(cache.begin(), cache, map[key]); return map[key]->second; } void put(int key, int value) { if (get(key) != -1) { map[key]->second = value; } else { if (cache.size() == capacity) { map.erase(cache.back().first); cache.pop_back(); } cache.push_front({key, value}); map[key] = cache.begin(); } } };",Useful
Calculates the Levenshtein distance between two strings using dynamic programming,"def levenshtein_distance(s1, s2): m, n = len(s1), len(s2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): dp[i][0] = i for j in range(n + 1): dp[0][j] = j for i in range(1, m + 1): for j in range(1, n + 1): if s1[i-1] == s2[j-1]: dp[i][j] = dp[i-1][j-1] else: dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) return dp[m][n]",Useful
This function does something with timers,"const debounce = (func, delay) => { let timeoutId; return (...args) => { clearTimeout(timeoutId); timeoutId = setTimeout(() => func.apply(this, args), delay); }; };",Not Useful
Processes a vector of events using a trait bound and iterators,fn process_events<T: Event>(events: Vec<T>) -> Vec<EventResult> { events.into_iter().map(|event| event.process()).collect() },Useful
Implements an asynchronous lock with condition variable support,"class AsyncLock: def __init__(self): self._lock = asyncio.Lock() self._condition = asyncio.Condition(self._lock) async def acquire(self): await self._lock.acquire() def release(self): self._lock.release() async def wait(self): await self._condition.wait() def notify(self): self._condition.notify() def notify_all(self): self._condition.notify_all() async def __aenter__(self): await self.acquire() return self async def __aexit__(self, exc_type, exc, tb): self.release()",Useful
Defines a concept for sortable types in C++20,"template <typename T> concept Sortable = requires(T a, T b) { { a < b } -> std::convertible_to<bool>; { a > b } -> std::convertible_to<bool>; { a <= b } -> std::convertible_to<bool>; { a >= b } -> std::convertible_to<bool>; { a == b } -> std::convertible_to<bool>; { a != b } -> std::convertible_to<bool>; };",Useful
This decorator does something with functions,"def coroutine_decorator(func): @functools.wraps(func) def primer(*args, **kwargs): gen = func(*args, **kwargs) next(gen) return gen return primer",Not Useful
Demonstrates the use of async generators and for-await-of loops in JavaScript,"async function* asyncGenerator(start, end) { for (let i = start; i <= end; i++) { await new Promise(resolve => setTimeout(resolve, 1000)); yield i; } } async function useAsyncGenerator() { for await (const num of asyncGenerator(1, 5)) { console.log(num); } }",Useful
Implements function composition in Rust using higher-order functions and closures,"fn compose<A, B, C, G, F>(f: F, g: G) -> impl Fn(A) -> C where F: Fn(B) -> C, G: Fn(A) -> B { move |x| f(g(x)) }",Useful
Implements a metaclass that automatically wraps properties with logging functionality,"class MetaPropertyAccessor(type): def __new__(cls, name, bases, attrs): for key, value in attrs.items(): if isinstance(value, property): attrs[key] = cls._wrap_property(value) return super().__new__(cls, name, bases, attrs) @staticmethod def _wrap_property(prop): @property def wrapped(self): value = prop.fget(self) print(f'Accessing property: {value}') return value return wrapped class MyClass(metaclass=MetaPropertyAccessor): @property def my_property(self): return 42",Useful
Creates a curried version of a function,"def curry(func): def curried(*args, **kwargs): if len(args) + len(kwargs) >= func.__code__.co_argcount: return func(*args, **kwargs) return lambda *more_args, **more_kwargs: curried(*args, *more_args, **kwargs, **more_kwargs) return curried",Useful
This function creates a unique pointer,"template <typename T, typename... Args> std::unique_ptr<T> make_unique(Args&&... args) { return std::unique_ptr<T>(new T(std::forward<Args>(args)...)); }",Not Useful
Implements a parallel map operation using Rayon in Rust,"fn parallel_map<T, U, F>(input: Vec<T>, f: F) -> Vec<U> where T: Send + Sync, U: Send, F: Fn(&T) -> U + Send + Sync { input.par_iter().map(f).collect() }",Useful
Implements the Proxy design pattern in Python with attribute access logging,"class ProxyPattern: def __init__(self, obj): self._obj = obj def __getattr__(self, name): print(f'Accessing attribute: {name}') return getattr(self._obj, name) def __setattr__(self, name, value): if name == '_obj': super().__setattr__(name, value) else: print(f'Setting attribute: {name} = {value}') setattr(self._obj, name, value)",Useful
Implements a simple observable pattern in JavaScript,"const createObservable = () => { const observers = new Set(); return { subscribe: (observer) => { observers.add(observer); return () => observers.delete(observer); }, notify: (data) => observers.forEach(observer => observer(data)) }; };",Useful
This function does something with patterns,"def coroutine(func): @functools.wraps(func) def wrapper(*args, **kwargs): gen = func(*args, **kwargs) next(gen) return gen return wrapper @coroutine def grep(pattern): print(f'Looking for {pattern}') while True: line = yield if pattern in line: print(line)",Not Useful
Demonstrates how to get the type name of a value at runtime in Rust,"fn type_name_of<T>(_: T) -> &'static str { std::any::type_name::<T>() } fn main() { println!(""{}"", type_name_of(42)); println!(""{}"", type_name_of(""hello"")); println!(""{}"", type_name_of(vec![1, 2, 3])); }",Useful
Implements a lazy property descriptor for on-demand computation and caching,"class LazyProperty: def __init__(self, func): self.func = func def __get__(self, instance, owner): if instance is None: return self value = self.func(instance) setattr(instance, self.func.__name__, value) return value class Example: @LazyProperty def expensive_computation(self): print('Computing...') return sum(range(1000000))",Useful
Demonstrates function composition and point-free style programming in JavaScript,"const pipe = (...fns) => (x) => fns.reduce((v, f) => f(v), x); const add = (a) => (b) => a + b; const multiply = (a) => (b) => a * b; const divide = (a) => (b) => b / a; const calculate = pipe(add(2), multiply(3), divide(4)); console.log(calculate(5)); // Output: 5.25",Useful
Implements a custom context manager decorator in Python,"def contextmanager(func): @functools.wraps(func) def helper(*args, **kwargs): generator = func(*args, **kwargs) try: item = next(generator) try: yield item except Exception as e: try: generator.throw(e) except StopIteration: pass else: raise RuntimeError(""generator didn't stop after throw()"") else: try: next(generator) except StopIteration: pass else: raise RuntimeError(""generator didn't stop"") finally: generator.close() return helper",Useful
This code defines a concept and a class,template <typename T> concept Hashable = requires(T a) { { std::hash<T>{}(a) } -> std::convertible_to<std::size_t>; }; template <Hashable T> class MyHashSet { // Implementation details };,Not Useful
Implements a future chain in Rust that repeatedly calls a function until it returns Some value,"fn create_future_chain<F, Fut, T>(mut f: F) -> impl Future<Output = T> where F: FnMut() -> Fut, Fut: Future<Output = Option<T>>, { async move { loop { if let Some(value) = f().await { return value; } } } }",Useful
Implements the Singleton design pattern using a metaclass in Python,"class Singleton(type): _instances = {} def __call__(cls, *args, **kwargs): if cls not in cls._instances: cls._instances[cls] = super(Singleton, cls).__call__(*args, **kwargs) return cls._instances[cls] class MyClass(metaclass=Singleton): def __init__(self): self.value = None",Useful
Implements a simple state machine factory in JavaScript,"const createMachine = (stateMachineDefinition) => { let currentState = stateMachineDefinition.initialState; const transition = (event) => { const currentStateDefinition = stateMachineDefinition[currentState]; const destinationTransition = currentStateDefinition.transitions[event]; if (!destinationTransition) { return; } const destinationState = destinationTransition.target; const destinationStateDefinition = stateMachineDefinition[destinationState]; destinationTransition.action(); currentStateDefinition.exit(); destinationStateDefinition.entry(); currentState = destinationState; }; return { transition, getCurrentState: () => currentState, }; };",Useful
Creates a decorator for tracing function calls,"def trace(func): @functools.wraps(func) def wrapper(*args, **kwargs): print(f'TRACE: Calling {func.__name__}() with {args}, {kwargs}') original_result = func(*args, **kwargs) print(f'TRACE: {func.__name__}() returned {original_result!r}') return original_result return wrapper @trace def say(name, line): return f'{name}: {line}'",Useful
This code implements an iterator,impl<T> Iterator for IntoIter<T> { type Item = T; fn next(&mut self) -> Option<T> { if self.len == 0 { None } else { self.len -= 1; unsafe { Some(ptr::read(self.ptr)) } } } },Not Useful
Transforms a function operating on strings/words to one operating on numbers/indices,"def conjugate(self, f): return lambda i: self.word_index[f(self.index_word[i])]",Useful
This function does something with caching.,def memoize(f): cache = {} def memoized(*args): if args not in cache: cache[args] = f(*args) return cache[args] return memoized,Not Useful
"Parses a JSON string into a Rust struct, using serde for deserialization","fn parse_json<T: DeserializeOwned>(input: &str) -> Result<T, serde_json::Error> { serde_json::from_str(input) }",Useful
Creates a debounced version of a function to limit its execution frequency,"const debounce = (func, delay) => { let timeoutId; return (...args) => { clearTimeout(timeoutId); timeoutId = setTimeout(() => func(...args), delay); }; };",Useful
This class implements a queue.,"template<typename T> class ThreadSafeQueue { private: std::queue<T> queue; mutable std::mutex mutex; std::condition_variable cond; public: void push(T value) { std::lock_guard<std::mutex> lock(mutex); queue.push(std::move(value)); cond.notify_one(); } T pop() { std::unique_lock<std::mutex> lock(mutex); cond.wait(lock, [this] { return !queue.empty(); }); T value = std::move(queue.front()); queue.pop(); return value; } };",Not Useful
Implements a fetch function with exponential backoff retry mechanism,"async function fetchWithRetry(url, options = {}, maxRetries = 3) { for (let i = 0; i < maxRetries; i++) { try { const response = await fetch(url, options); if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`); return await response.json(); } catch (e) { if (i === maxRetries - 1) throw e; await new Promise(resolve => setTimeout(resolve, 1000 * Math.pow(2, i))); } } }",Useful
Decorator to automatically start a coroutine function,"def coroutine(func): def start(*args, **kwargs): cr = func(*args, **kwargs) next(cr) return cr return start",Useful
This function does something with references.,impl<T: Clone> Rc<T> { pub fn make_mut(this: &mut Self) -> &mut T { if Rc::strong_count(this) != 1 { *this = Rc::new((**this).clone()); } unsafe { &mut **this.ptr.as_mut() } } },Not Useful
Implements a Least Recently Used (LRU) cache with a fixed capacity,"class LRUCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = OrderedDict() def get(self, key: int) -> int: if key not in self.cache: return -1 self.cache.move_to_end(key) return self.cache[key] def put(self, key: int, value: int) -> None: if key in self.cache: self.cache.move_to_end(key) self.cache[key] = value if len(self.cache) > self.capacity: self.cache.popitem(last=False)",Useful
Defines a concept in C++20 for types that can be printed to std::cout,template <typename T> concept Printable = requires(T t) { { std::cout << t } -> std::same_as<std::ostream&>; };,Useful
This function does something with arguments.,"function curry(fn) { return function curried(...args) { if (args.length >= fn.length) { return fn.apply(this, args); } else { return function(...args2) { return curried.apply(this, args.concat(args2)); }; } }; }",Not Useful
Implements the quicksort algorithm with in-place partitioning in Rust,"pub fn quicksort<T: Ord>(arr: &mut [T]) { if arr.len() <= 1 { return; } let pivot = partition(arr); quicksort(&mut arr[..pivot]); quicksort(&mut arr[pivot + 1..]); } fn partition<T: Ord>(arr: &mut [T]) -> usize { let pivot = arr.len() - 1; let mut i = 0; for j in 0..pivot { if arr[j] <= arr[pivot] { arr.swap(i, j); i += 1; } } arr.swap(i, pivot); i }",Useful
Generates prime numbers using the Sieve of Eratosthenes algorithm,"def generate_primes(n): sieve = [True] * (n + 1) sieve[0] = sieve[1] = False for i in range(2, int(n**0.5) + 1): if sieve[i]: for j in range(i*i, n+1, i): sieve[j] = False return [i for i in range(2, n+1) if sieve[i]]",Useful
This class does something with observers.,class Observable { constructor() { this.observers = []; } subscribe(fn) { this.observers.push(fn); } unsubscribe(fn) { this.observers = this.observers.filter(subscriber => subscriber !== fn); } notify(data) { this.observers.forEach(observer => observer(data)); } },Not Useful
Calculates the Levenshtein distance between two strings using dynamic programming,"def levenshtein_distance(s1, s2): if len(s1) < len(s2): return levenshtein_distance(s2, s1) if len(s2) == 0: return len(s1) previous_row = range(len(s2) + 1) for i, c1 in enumerate(s1): current_row = [i + 1] for j, c2 in enumerate(s2): insertions = previous_row[j + 1] + 1 deletions = current_row[j] + 1 substitutions = previous_row[j] + (c1 != c2) current_row.append(min(insertions, deletions, substitutions)) previous_row = current_row return previous_row[-1]",Useful
Implements a parallel map operation using Rayon in Rust,"fn parallel_map<T, U, F>(input: &[T], f: F) -> Vec<U> where T: Sync, U: Send, F: Fn(&T) -> U + Sync + Send { input.par_iter().map(f).collect() }",Useful
This class creates an object.,class Singleton: _instance = None def __new__(cls): if cls._instance is None: cls._instance = super().__new__(cls) return cls._instance,Not Useful
Implements a C++11 version of make_unique for creating unique_ptr objects,"template<typename T, typename... Args> std::unique_ptr<T> make_unique(Args&&... args) { return std::unique_ptr<T>(new T(std::forward<Args>(args)...)); }",Useful
Creates a memoized version of a function to cache its results,"function memoize(fn) { const cache = new Map(); return function(...args) { const key = JSON.stringify(args); if (cache.has(key)) { return cache.get(key); } const result = fn.apply(this, args); cache.set(key, result); return result; }; }",Useful
This function does something with graphs.,def topological_sort(graph): def dfs(node): if node in visited: return visited.add(node) for neighbor in graph[node]: dfs(neighbor) result.append(node) visited = set() result = [] for node in graph: dfs(node) return result[::-1],Not Useful
Implements a custom drop method for a LinkedList to avoid stack overflow on large lists,impl<T> Drop for LinkedList<T> { fn drop(&mut self) { while let Some(node) = self.head.take() { self.head = unsafe { Box::from_raw(node.as_ref().next) }; } } },Useful
Implements partial application for functions in Python,"def partial_application(func, *args, **kwargs): def wrapper(*more_args, **more_kwargs): all_args = args + more_args all_kwargs = {**kwargs, **more_kwargs} return func(*all_args, **all_kwargs) return wrapper",Useful
This class does something with threads.,"template <typename T> class ThreadSafeQueue { private: std::queue<T> queue; mutable std::mutex mutex; std::condition_variable cond; public: void push(T value) { std::lock_guard<std::mutex> lock(mutex); queue.push(std::move(value)); cond.notify_one(); } T pop() { std::unique_lock<std::mutex> lock(mutex); cond.wait(lock, [this] { return !queue.empty(); }); T value = std::move(queue.front()); queue.pop(); return value; } };",Not Useful
Creates a proxy object with custom logging behavior for property access and modification,"function createProxy(target, handler) { return new Proxy(target, { get(target, property, receiver) { console.log(`Accessing property: ${property}`); return Reflect.get(target, property, receiver); }, set(target, property, value, receiver) { console.log(`Setting property: ${property} = ${value}`); return Reflect.set(target, property, value, receiver); }, ...handler }); }",Useful
Implements a coroutine-based grep function using Python generators,"def coroutine(func): def start(*args, **kwargs): cr = func(*args, **kwargs) next(cr) return cr return start @coroutine def grep(pattern): print(f""Looking for {pattern}"") while True: line = yield if pattern in line: print(line)",Useful
This function searches for something.,"fn binary_search<T: Ord>(arr: &[T], target: &T) -> Option<usize> { let mut left = 0; let mut right = arr.len(); while left < right { let mid = left + (right - left) / 2; match arr[mid].cmp(target) { std::cmp::Ordering::Equal => return Some(mid), std::cmp::Ordering::Less => left = mid + 1, std::cmp::Ordering::Greater => right = mid, } } None }",Not Useful
Implements a lazy property decorator for Python classes,"class LazyProperty: def __init__(self, func): self.func = func def __get__(self, instance, owner): if instance is None: return self value = self.func(instance) setattr(instance, self.func.__name__, value) return value",Useful
Defines a concept in C++20 for types that can be used as keys in hash-based containers,template <typename T> concept Hashable = requires(T a) { { std::hash<T>{}(a) } -> std::convertible_to<std::size_t>; { a == a } -> std::convertible_to<bool>; { a != a } -> std::convertible_to<bool>; };,Useful
This function does something with functions.,"function compose(...fns) { return fns.reduce((f, g) => (...args) => f(g(...args))); }",Not Useful
Implements a Least Recently Used (LRU) cache decorator in Python,"def lru_cache(maxsize=128): def decorator(func): cache = OrderedDict() @wraps(func) def wrapper(*args, **kwargs): key = str(args) + str(kwargs) if key not in cache: if len(cache) >= maxsize: cache.popitem(last=False) cache[key] = func(*args, **kwargs) else: cache.move_to_end(key) return cache[key] return wrapper return decorator",Useful
Implements a copy-on-write mechanism for Rc<T> in Rust,impl<T: Clone> Rc<T> { pub fn make_mut(this: &mut Self) -> &mut T { if Rc::strong_count(this) != 1 { *this = Rc::new((**this).clone()); } unsafe { &mut **this.ptr.as_mut() } } },Useful
This class does something with objects.,"class Observable: def __init__(self): self._observers = [] def attach(self, observer): if observer not in self._observers: self._observers.append(observer) def detach(self, observer): try: self._observers.remove(observer) except ValueError: pass def notify(self, *args, **kwargs): for observer in self._observers: observer.update(self, *args, **kwargs)",Not Useful
Defines a concept in C++20 for callable types that can be invoked with given arguments,"template<typename F, typename... Args> concept invocable = requires(F&& f, Args&&... args) { std::invoke(std::forward<F>(f), std::forward<Args>(args)...); };",Useful
Runs an asynchronous coroutine with a timeout using Python's asyncio,"def asyncio_run_with_timeout(coro, timeout): async def wrapper(): return await asyncio.wait_for(coro, timeout) return asyncio.run(wrapper())",Useful
Transforms a function operating on strings/words to operate on corresponding numeric indices,"def conjugate(self, f): return lambda i: self.word_index[f(self.index_word[i])]",Useful
This function does something with caching.,def memoize(func): cache = {}; def wrapper(*args): if args not in cache: cache[args] = func(*args); return cache[args]; return wrapper,Not Useful
Implements an exponential backoff retry mechanism for fetching data from a URL,"async function fetchWithRetry(url, maxRetries = 3) { for (let i = 0; i < maxRetries; i++) { try { const response = await fetch(url); if (response.ok) return response.json(); } catch (error) { if (i === maxRetries - 1) throw error; } await new Promise(resolve => setTimeout(resolve, 1000 * Math.pow(2, i))); } }",Useful
"Parses a duration string into a Duration object, supporting days, hours, minutes, and seconds","fn parse_duration(input: &str) -> Result<Duration, ParseError> { let mut total = Duration::new(0, 0); let mut current = 0; for c in input.chars() { match c { '0'..='9' => current = current * 10 + c.to_digit(10).unwrap() as u64, 's' => { total += Duration::from_secs(current); current = 0; } 'm' => { total += Duration::from_secs(current * 60); current = 0; } 'h' => { total += Duration::from_secs(current * 3600); current = 0; } 'd' => { total += Duration::from_secs(current * 86400); current = 0; } _ => return Err(ParseError::InvalidCharacter(c)), } } if current != 0 { return Err(ParseError::MissingUnit); } Ok(total) }",Useful
This class implements a queue.,"template<typename T> class ThreadSafeQueue { private: std::queue<T> queue; mutable std::mutex mutex; std::condition_variable cond; public: void push(T item) { std::unique_lock<std::mutex> lock(mutex); queue.push(std::move(item)); lock.unlock(); cond.notify_one(); } T pop() { std::unique_lock<std::mutex> lock(mutex); cond.wait(lock, [this]{ return !queue.empty(); }); T item = std::move(queue.front()); queue.pop(); return item; } };",Not Useful
Calculates the Levenshtein distance between two strings using dynamic programming,"def levenshtein_distance(s1, s2): if len(s1) < len(s2): return levenshtein_distance(s2, s1); if len(s2) == 0: return len(s1); previous_row = range(len(s2) + 1); for i, c1 in enumerate(s1): current_row = [i + 1]; for j, c2 in enumerate(s2): insertions = previous_row[j + 1] + 1; deletions = current_row[j] + 1; substitutions = previous_row[j] + (c1 != c2); current_row.append(min(insertions, deletions, substitutions)); previous_row = current_row; return previous_row[-1]",Useful
This function does something with timing.,"const debounce = (func, delay) => { let timeoutId; return (...args) => { clearTimeout(timeoutId); timeoutId = setTimeout(() => func.apply(null, args), delay); }; };",Not Useful
Implements the quicksort algorithm with in-place partitioning for any orderable type,"fn quick_sort<T: Ord>(arr: &mut [T]) { if arr.len() <= 1 { return; } let pivot = partition(arr); quick_sort(&mut arr[0..pivot]); quick_sort(&mut arr[pivot + 1..]); } fn partition<T: Ord>(arr: &mut [T]) -> usize { let pivot = arr.len() - 1; let mut i = 0; for j in 0..pivot { if arr[j] <= arr[pivot] { arr.swap(i, j); i += 1; } } arr.swap(i, pivot); i }",Useful
Implements a Least Recently Used (LRU) cache with a specified capacity,"class LRUCache: def __init__(self, capacity: int): self.capacity = capacity; self.cache = OrderedDict(); def get(self, key: int) -> int: if key not in self.cache: return -1; self.cache.move_to_end(key); return self.cache[key]; def put(self, key: int, value: int) -> None: if key in self.cache: self.cache.move_to_end(key); self.cache[key] = value; if len(self.cache) > self.capacity: self.cache.popitem(last=False)",Useful
This function generates numbers.,"function* fibonacciGenerator() { let a = 0, b = 1; while (true) { yield a; [a, b] = [b, a + b]; } }",Not Useful
Implements a thread-safe shared pointer with reference counting,"template <typename T> class SharedPtr { private: T* ptr; std::atomic<int>* refCount; public: explicit SharedPtr(T* p = nullptr) : ptr(p), refCount(new std::atomic<int>(1)) {} SharedPtr(const SharedPtr& other) : ptr(other.ptr), refCount(other.refCount) { refCount->fetch_add(1); } SharedPtr& operator=(const SharedPtr& other) { if (this != &other) { release(); ptr = other.ptr; refCount = other.refCount; refCount->fetch_add(1); } return *this; } ~SharedPtr() { release(); } T& operator*() const { return *ptr; } T* operator->() const { return ptr; } private: void release() { if (refCount->fetch_sub(1) == 1) { delete ptr; delete refCount; } } };",Useful
This function does something with text.,"def tokenize(text): return re.findall(r'\w+|[^\w\s]', text.lower())",Not Useful
Implements an asynchronous pool with a limit on concurrent executions,"async function asyncPool(poolLimit, array, iteratorFn) { const ret = []; const executing = new Set(); for (const item of array) { const p = Promise.resolve().then(() => iteratorFn(item, array)); ret.push(p); executing.add(p); const clean = () => executing.delete(p); p.then(clean).catch(clean); if (executing.size >= poolLimit) { await Promise.race(executing); } } return Promise.all(ret); }",Useful
This function checks if a string is the same forwards and backwards.,fn is_palindrome(s: &str) -> bool { let s: Vec<char> = s.chars().filter(|c| c.is_alphanumeric()).collect(); s.iter().eq(s.iter().rev()) },Not Useful
Implements a Trie data structure for efficient prefix-based string operations,"class Trie: def __init__(self): self.root = {}; def insert(self, word: str) -> None: node = self.root; for char in word: if char not in node: node[char] = {}; node = node[char]; node['$'] = True; def search(self, word: str) -> bool: node = self.root; for char in word: if char not in node: return False; node = node[char]; return '$' in node; def startsWith(self, prefix: str) -> bool: node = self.root; for char in prefix: if char not in node: return False; node = node[char]; return True",Useful
This function does something with functions.,"const curry = (fn) => { return function curried(...args) { if (args.length >= fn.length) { return fn.apply(this, args); } else { return function(...args2) { return curried.apply(this, args.concat(args2)); } } }; };",Not Useful
Implements a fixed-size ring buffer using a circular array,"template<typename T, size_t N> class FixedRingBuffer { private: std::array<T, N> buffer; size_t head = 0; size_t tail = 0; bool full = false; public: void push(const T& item) { buffer[head] = item; if (full) { tail = (tail + 1) % N; } head = (head + 1) % N; full = head == tail; } T pop() { if (empty()) { throw std::out_of_range(""Buffer is empty""); } T item = buffer[tail]; full = false; tail = (tail + 1) % N; return item; } bool empty() const { return (!full && (head == tail)); } bool full() const { return full; } };",Useful
This function does something with intervals.,"def merge_intervals(intervals): intervals.sort(key=lambda x: x[0]); merged = []; for interval in intervals: if not merged or merged[-1][1] < interval[0]: merged.append(interval); else: merged[-1][1] = max(merged[-1][1], interval[1]); return merged",Not Useful
Compresses a string by replacing consecutive repeated characters with the character followed by its count,fn compress_string(s: &str) -> String { let mut result = String::new(); let mut chars = s.chars().peekable(); while let Some(current) = chars.next() { let mut count = 1; while chars.peek() == Some(&current) { count += 1; chars.next(); } result.push(current); if count > 1 { result.push_str(&count.to_string()); } } if result.len() < s.len() { result } else { s.to_string() } },Useful
This class does something with properties.,"class LazyProperty: def __init__(self, func): self.func = func; def __get__(self, instance, owner): if instance is None: return self; value = self.func(instance); setattr(instance, self.func.__name__, value); return value",Not Useful
Implements a simple observable pattern for pub/sub functionality,"function createObservable() { const observers = new Set(); return { subscribe: (observer) => { observers.add(observer); return { unsubscribe: () => observers.delete(observer) }; }, notify: (data) => { observers.forEach(observer => observer(data)); } }; }",Useful
This function does something with graphs.,def topological_sort(graph): def dfs(node): if node in visited: return; visited.add(node); for neighbor in graph[node]: dfs(neighbor); result.append(node); visited = set(); result = []; for node in graph: dfs(node); return result[::-1],Not Useful
Implements a Skip List data structure for efficient searching and insertion operations,"template <typename T> class SkipList { private: struct Node { T value; std::vector<Node*> forward; Node(T v, int level) : value(v), forward(level, nullptr) {} }; Node* head; int maxLevel; float p; int level; int randomLevel() { int lvl = 1; while ((static_cast<float>(rand()) / RAND_MAX) < p && lvl < maxLevel) { lvl++; } return lvl; } public: SkipList(int maxLvl = 32, float prob = 0.5) : maxLevel(maxLvl), p(prob), level(0) { head = new Node(T(), maxLevel); } void insert(T value) { std::vector<Node*> update(maxLevel, nullptr); Node* current = head; for (int i = level - 1; i >= 0; i--) { while (current->forward[i] && current->forward[i]->value < value) { current = current->forward[i]; } update[i] = current; } int newLevel = randomLevel(); if (newLevel > level) { for (int i = level; i < newLevel; i++) { update[i] = head; } level = newLevel; } Node* newNode = new Node(value, newLevel); for (int i = 0; i < newLevel; i++) { newNode->forward[i] = update[i]->forward[i]; update[i]->forward[i] = newNode; } } bool search(T value) { Node* current = head; for (int i = level - 1; i >= 0; i--) { while (current->forward[i] && current->forward[i]->value < value) { current = current->forward[i]; } } current = current->forward[0]; return (current && current->value == value); } };",Useful
This function does something with averages.,"def calculate_moving_average(data, window_size): cumsum = np.cumsum(np.insert(data, 0, 0)); return (cumsum[window_size:] - cumsum[:-window_size]) / window_size",Not Useful
Implements a basic event emitter pattern for handling custom events,"class EventEmitter { constructor() { this.listeners = {}; } on(event, callback) { if (!this.listeners[event]) { this.listeners[event] = []; } this.listeners[event].push(callback); } emit(event, ...args) { if (this.listeners[event]) { this.listeners[event].forEach(callback => callback(...args)); } } off(event, callback) { if (this.listeners[event]) { this.listeners[event] = this.listeners[event].filter(cb => cb !== callback); } } }",Useful
This function finds the longest subsequence in a string.,"fn longest_palindromic_subsequence(s: &str) -> usize { let n = s.len(); let chars: Vec<char> = s.chars().collect(); let mut dp = vec![vec![0; n]; n]; for i in 0..n { dp[i][i] = 1; } for len in 2..=n { for i in 0..n-len+1 { let j = i + len - 1; if chars[i] == chars[j] && len == 2 { dp[i][j] = 2; } else if chars[i] == chars[j] { dp[i][j] = dp[i+1][j-1] + 2; } else { dp[i][j] = std::cmp::max(dp[i+1][j], dp[i][j-1]); } } } dp[0][n-1] }",Not Useful
Implements a circular buffer (ring buffer) with fixed capacity in TypeScript,class CircularBuffer<T> { private buffer: T[]; private head: number = 0; private tail: number = 0; private size: number = 0; constructor(private capacity: number) { this.buffer = new Array<T>(capacity); } push(item: T): void { if (this.size === this.capacity) { this.head = (this.head + 1) % this.capacity; } else { this.size++; } this.buffer[this.tail] = item; this.tail = (this.tail + 1) % this.capacity; } pop(): T | undefined { if (this.size === 0) return undefined; const item = this.buffer[this.head]; this.head = (this.head + 1) % this.capacity; this.size--; return item; } get length(): number { return this.size; } isFull(): boolean { return this.size === this.capacity; } isEmpty(): boolean { return this.size === 0; } },Useful
This function searches for patterns in text.,"def kmp_search(text, pattern): m = len(pattern); n = len(text); lps = [0] * m; j = 0; compute_lps_array(pattern, m, lps); i = 0; while i < n: if pattern[j] == text[i]: i += 1; j += 1; if j == m: print(f""Found pattern at index {i - j}""); j = lps[j - 1]; elif i < n and pattern[j] != text[i]: if j != 0: j = lps[j - 1]; else: i += 1; def compute_lps_array(pattern, m, lps): len = 0; lps[0] = 0; i = 1; while i < m: if pattern[i] == pattern[len]: len += 1; lps[i] = len; i += 1; else: if len != 0: len = lps[len - 1]; else: lps[i] = 0; i += 1",Not Useful
Implements a Bloom filter data structure with customizable size and hash functions,"class BloomFilter { constructor(size, hashFunctions) { this.size = size; this.hashFunctions = hashFunctions; this.bitArray = new Array(size).fill(0); } add(item) { this.hashFunctions.forEach(hashFunc => { const index = hashFunc(item) % this.size; this.bitArray[index] = 1; }); } contains(item) { return this.hashFunctions.every(hashFunc => { const index = hashFunc(item) % this.size; return this.bitArray[index] === 1; }); } }",Useful
This function counts something in an array.,"def count_inversions(arr): def merge_sort(arr): if len(arr) <= 1: return arr, 0; mid = len(arr) // 2; left, inv_left = merge_sort(arr[:mid]); right, inv_right = merge_sort(arr[mid:]); merged, inv_merge = merge(left, right); return merged, inv_left + inv_right + inv_merge; def merge(left, right): result = []; inv_count = 0; i, j = 0, 0; while i < len(left) and j < len(right): if left[i] <= right[j]: result.append(left[i]); i += 1; else: result.append(right[j]); inv_count += len(left) - i; j += 1; result.extend(left[i:]); result.extend(right[j:]); return result, inv_count; _, inversions = merge_sort(arr); return inversions",Not Useful
Implements the Rabin-Karp string matching algorithm for efficient pattern searching,"fn rabin_karp(text: &str, pattern: &str) -> Vec<usize> { let prime: u64 = 101; let m = pattern.len(); let n = text.len(); let mut pattern_hash: u64 = 0; let mut text_hash: u64 = 0; let mut h: u64 = 1; let mut result = Vec::new(); if m > n { return result; } for i in 0..m-1 { h = (h * 256) % prime; } for i in 0..m { pattern_hash = (256 * pattern_hash + pattern.as_bytes()[i] as u64) % prime; text_hash = (256 * text_hash + text.as_bytes()[i] as u64) % prime; } for i in 0..=n-m { if pattern_hash == text_hash { if &text[i..i+m] == pattern { result.push(i); } } if i < n-m { text_hash = (256 * (text_hash + prime - (text.as_bytes()[i] as u64 * h) % prime) % prime + text.as_bytes()[i+m] as u64) % prime; } } result }",Useful
Implements a Least Frequently Used (LFU) cache with O(1) time complexity for get and put operations,"class LFUCache { constructor(capacity) { this.capacity = capacity; this.keyToVal = new Map(); this.keyToCount = new Map(); this.countToLRU = new Map(); this.minCount = 0; } get(key) { if (!this.keyToVal.has(key)) return -1; const count = this.keyToCount.get(key); this.keyToCount.set(key, count + 1); this.countToLRU.get(count).delete(key); if (count === this.minCount && this.countToLRU.get(count).size === 0) { this.minCount++; } this.countToLRU.get(count + 1)?.set(key, true) || this.countToLRU.set(count + 1, new Map([[key, true]])); return this.keyToVal.get(key); } put(key, value) { if (this.capacity <= 0) return; if (this.keyToVal.has(key)) { this.keyToVal.set(key, value); this.get(key); return; } if (this.keyToVal.size >= this.capacity) { const lru = this.countToLRU.get(this.minCount); const evictKey = lru.keys().next().value; lru.delete(evictKey); this.keyToVal.delete(evictKey); this.keyToCount.delete(evictKey); } this.keyToVal.set(key, value); this.keyToCount.set(key, 1); this.countToLRU.get(1)?.set(key, true) || this.countToLRU.set(1, new Map([[key, true]])); this.minCount = 1; }}",Useful
This function checks if a number is prime.,"def is_prime(n): if n < 2: return False; for i in range(2, int(n**0.5) + 1): if n % i == 0: return False; return True",Not Useful
This function implements Huffman encoding.,"fn huffman_encoding(text: &str) -> (String, std::collections::HashMap<char, String>) { use std::collections::{BinaryHeap, HashMap}; use std::cmp::Reverse",Useful
